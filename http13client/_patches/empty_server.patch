=== modified file 'http13client/serve_test.go'
--- http13client/serve_test.go	2014-06-20 11:00:47 +0000
+++ http13client/serve_test.go	2014-06-20 12:00:22 +0000
@@ -2,60 +2,15 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// End-to-end serving tests
-
 package http_test
 
 import (
-	"bufio"
-	"bytes"
-	"crypto/tls"
-	"errors"
-	"fmt"
 	"io"
-	"io/ioutil"
-	"log"
 	"net"
-	. "github.com/ubports/ubuntu-push/http13client"
-	"net/http/httptest"
-	"net/http/httputil"
-	"net/url"
-	"os"
-	"os/exec"
-	"reflect"
-	"runtime"
-	"strconv"
-	"strings"
-	"sync"
-	"sync/atomic"
-	"syscall"
-	"testing"
 	"time"
 )
 
 type dummyAddr string
-type oneConnListener struct {
-	conn net.Conn
-}
-
-func (l *oneConnListener) Accept() (c net.Conn, err error) {
-	c = l.conn
-	if c == nil {
-		err = io.EOF
-		return
-	}
-	err = nil
-	l.conn = nil
-	return
-}
-
-func (l *oneConnListener) Close() error {
-	return nil
-}
-
-func (l *oneConnListener) Addr() net.Addr {
-	return dummyAddr("test-address")
-}
 
 func (a dummyAddr) Network() string {
 	return string(a)
@@ -93,1325 +48,6 @@
 	return nil
 }
 
-type testConn struct {
-	readBuf  bytes.Buffer
-	writeBuf bytes.Buffer
-	closec   chan bool // if non-nil, send value to it on close
-	noopConn
-}
-
-func (c *testConn) Read(b []byte) (int, error) {
-	return c.readBuf.Read(b)
-}
-
-func (c *testConn) Write(b []byte) (int, error) {
-	return c.writeBuf.Write(b)
-}
-
-func (c *testConn) Close() error {
-	select {
-	case c.closec <- true:
-	default:
-	}
-	return nil
-}
-
-// reqBytes treats req as a request (with \n delimiters) and returns it with \r\n delimiters,
-// ending in \r\n\r\n
-func reqBytes(req string) []byte {
-	return []byte(strings.Replace(strings.TrimSpace(req), "\n", "\r\n", -1) + "\r\n\r\n")
-}
-
-type handlerTest struct {
-	handler Handler
-}
-
-func newHandlerTest(h Handler) handlerTest {
-	return handlerTest{h}
-}
-
-func (ht handlerTest) rawResponse(req string) string {
-	reqb := reqBytes(req)
-	var output bytes.Buffer
-	conn := &rwTestConn{
-		Reader: bytes.NewReader(reqb),
-		Writer: &output,
-		closec: make(chan bool, 1),
-	}
-	ln := &oneConnListener{conn: conn}
-	go Serve(ln, ht.handler)
-	<-conn.closec
-	return output.String()
-}
-
-func TestConsumingBodyOnNextConn(t *testing.T) {
-	conn := new(testConn)
-	for i := 0; i < 2; i++ {
-		conn.readBuf.Write([]byte(
-			"POST / HTTP/1.1\r\n" +
-				"Host: test\r\n" +
-				"Content-Length: 11\r\n" +
-				"\r\n" +
-				"foo=1&bar=1"))
-	}
-
-	reqNum := 0
-	ch := make(chan *Request)
-	servech := make(chan error)
-	listener := &oneConnListener{conn}
-	handler := func(res ResponseWriter, req *Request) {
-		reqNum++
-		ch <- req
-	}
-
-	go func() {
-		servech <- Serve(listener, HandlerFunc(handler))
-	}()
-
-	var req *Request
-	req = <-ch
-	if req == nil {
-		t.Fatal("Got nil first request.")
-	}
-	if req.Method != "POST" {
-		t.Errorf("For request #1's method, got %q; expected %q",
-			req.Method, "POST")
-	}
-
-	req = <-ch
-	if req == nil {
-		t.Fatal("Got nil first request.")
-	}
-	if req.Method != "POST" {
-		t.Errorf("For request #2's method, got %q; expected %q",
-			req.Method, "POST")
-	}
-
-	if serveerr := <-servech; serveerr != io.EOF {
-		t.Errorf("Serve returned %q; expected EOF", serveerr)
-	}
-}
-
-type stringHandler string
-
-func (s stringHandler) ServeHTTP(w ResponseWriter, r *Request) {
-	w.Header().Set("Result", string(s))
-}
-
-var handlers = []struct {
-	pattern string
-	msg     string
-}{
-	{"/", "Default"},
-	{"/someDir/", "someDir"},
-	{"someHost.com/someDir/", "someHost.com/someDir"},
-}
-
-var vtests = []struct {
-	url      string
-	expected string
-}{
-	{"http://localhost/someDir/apage", "someDir"},
-	{"http://localhost/otherDir/apage", "Default"},
-	{"http://someHost.com/someDir/apage", "someHost.com/someDir"},
-	{"http://otherHost.com/someDir/apage", "someDir"},
-	{"http://otherHost.com/aDir/apage", "Default"},
-	// redirections for trees
-	{"http://localhost/someDir", "/someDir/"},
-	{"http://someHost.com/someDir", "/someDir/"},
-}
-
-func TestHostHandlers(t *testing.T) {
-	defer afterTest(t)
-	mux := NewServeMux()
-	for _, h := range handlers {
-		mux.Handle(h.pattern, stringHandler(h.msg))
-	}
-	ts := httptest.NewServer(mux)
-	defer ts.Close()
-
-	conn, err := net.Dial("tcp", ts.Listener.Addr().String())
-	if err != nil {
-		t.Fatal(err)
-	}
-	defer conn.Close()
-	cc := httputil.NewClientConn(conn, nil)
-	for _, vt := range vtests {
-		var r *Response
-		var req Request
-		if req.URL, err = url.Parse(vt.url); err != nil {
-			t.Errorf("cannot parse url: %v", err)
-			continue
-		}
-		if err := cc.Write(&req); err != nil {
-			t.Errorf("writing request: %v", err)
-			continue
-		}
-		r, err := cc.Read(&req)
-		if err != nil {
-			t.Errorf("reading response: %v", err)
-			continue
-		}
-		switch r.StatusCode {
-		case StatusOK:
-			s := r.Header.Get("Result")
-			if s != vt.expected {
-				t.Errorf("Get(%q) = %q, want %q", vt.url, s, vt.expected)
-			}
-		case StatusMovedPermanently:
-			s := r.Header.Get("Location")
-			if s != vt.expected {
-				t.Errorf("Get(%q) = %q, want %q", vt.url, s, vt.expected)
-			}
-		default:
-			t.Errorf("Get(%q) unhandled status code %d", vt.url, r.StatusCode)
-		}
-	}
-}
-
-var serveMuxRegister = []struct {
-	pattern string
-	h       Handler
-}{
-	{"/dir/", serve(200)},
-	{"/search", serve(201)},
-	{"codesearch.google.com/search", serve(202)},
-	{"codesearch.google.com/", serve(203)},
-	{"example.com/", HandlerFunc(checkQueryStringHandler)},
-}
-
-// serve returns a handler that sends a response with the given code.
-func serve(code int) HandlerFunc {
-	return func(w ResponseWriter, r *Request) {
-		w.WriteHeader(code)
-	}
-}
-
-// checkQueryStringHandler checks if r.URL.RawQuery has the same value
-// as the URL excluding the scheme and the query string and sends 200
-// response code if it is, 500 otherwise.
-func checkQueryStringHandler(w ResponseWriter, r *Request) {
-	u := *r.URL
-	u.Scheme = "http"
-	u.Host = r.Host
-	u.RawQuery = ""
-	if "http://"+r.URL.RawQuery == u.String() {
-		w.WriteHeader(200)
-	} else {
-		w.WriteHeader(500)
-	}
-}
-
-var serveMuxTests = []struct {
-	method  string
-	host    string
-	path    string
-	code    int
-	pattern string
-}{
-	{"GET", "google.com", "/", 404, ""},
-	{"GET", "google.com", "/dir", 301, "/dir/"},
-	{"GET", "google.com", "/dir/", 200, "/dir/"},
-	{"GET", "google.com", "/dir/file", 200, "/dir/"},
-	{"GET", "google.com", "/search", 201, "/search"},
-	{"GET", "google.com", "/search/", 404, ""},
-	{"GET", "google.com", "/search/foo", 404, ""},
-	{"GET", "codesearch.google.com", "/search", 202, "codesearch.google.com/search"},
-	{"GET", "codesearch.google.com", "/search/", 203, "codesearch.google.com/"},
-	{"GET", "codesearch.google.com", "/search/foo", 203, "codesearch.google.com/"},
-	{"GET", "codesearch.google.com", "/", 203, "codesearch.google.com/"},
-	{"GET", "images.google.com", "/search", 201, "/search"},
-	{"GET", "images.google.com", "/search/", 404, ""},
-	{"GET", "images.google.com", "/search/foo", 404, ""},
-	{"GET", "google.com", "/../search", 301, "/search"},
-	{"GET", "google.com", "/dir/..", 301, ""},
-	{"GET", "google.com", "/dir/..", 301, ""},
-	{"GET", "google.com", "/dir/./file", 301, "/dir/"},
-
-	// The /foo -> /foo/ redirect applies to CONNECT requests
-	// but the path canonicalization does not.
-	{"CONNECT", "google.com", "/dir", 301, "/dir/"},
-	{"CONNECT", "google.com", "/../search", 404, ""},
-	{"CONNECT", "google.com", "/dir/..", 200, "/dir/"},
-	{"CONNECT", "google.com", "/dir/..", 200, "/dir/"},
-	{"CONNECT", "google.com", "/dir/./file", 200, "/dir/"},
-}
-
-func TestServeMuxHandler(t *testing.T) {
-	mux := NewServeMux()
-	for _, e := range serveMuxRegister {
-		mux.Handle(e.pattern, e.h)
-	}
-
-	for _, tt := range serveMuxTests {
-		r := &Request{
-			Method: tt.method,
-			Host:   tt.host,
-			URL: &url.URL{
-				Path: tt.path,
-			},
-		}
-		h, pattern := mux.Handler(r)
-		rr := httptest.NewRecorder()
-		h.ServeHTTP(rr, r)
-		if pattern != tt.pattern || rr.Code != tt.code {
-			t.Errorf("%s %s %s = %d, %q, want %d, %q", tt.method, tt.host, tt.path, rr.Code, pattern, tt.code, tt.pattern)
-		}
-	}
-}
-
-var serveMuxTests2 = []struct {
-	method  string
-	host    string
-	url     string
-	code    int
-	redirOk bool
-}{
-	{"GET", "google.com", "/", 404, false},
-	{"GET", "example.com", "/test/?example.com/test/", 200, false},
-	{"GET", "example.com", "test/?example.com/test/", 200, true},
-}
-
-// TestServeMuxHandlerRedirects tests that automatic redirects generated by
-// mux.Handler() shouldn't clear the request's query string.
-func TestServeMuxHandlerRedirects(t *testing.T) {
-	mux := NewServeMux()
-	for _, e := range serveMuxRegister {
-		mux.Handle(e.pattern, e.h)
-	}
-
-	for _, tt := range serveMuxTests2 {
-		tries := 1
-		turl := tt.url
-		for tries > 0 {
-			u, e := url.Parse(turl)
-			if e != nil {
-				t.Fatal(e)
-			}
-			r := &Request{
-				Method: tt.method,
-				Host:   tt.host,
-				URL:    u,
-			}
-			h, _ := mux.Handler(r)
-			rr := httptest.NewRecorder()
-			h.ServeHTTP(rr, r)
-			if rr.Code != 301 {
-				if rr.Code != tt.code {
-					t.Errorf("%s %s %s = %d, want %d", tt.method, tt.host, tt.url, rr.Code, tt.code)
-				}
-				break
-			}
-			if !tt.redirOk {
-				t.Errorf("%s %s %s, unexpected redirect", tt.method, tt.host, tt.url)
-				break
-			}
-			turl = rr.HeaderMap.Get("Location")
-			tries--
-		}
-		if tries < 0 {
-			t.Errorf("%s %s %s, too many redirects", tt.method, tt.host, tt.url)
-		}
-	}
-}
-
-// Tests for http://code.google.com/p/go/issues/detail?id=900
-func TestMuxRedirectLeadingSlashes(t *testing.T) {
-	paths := []string{"//foo.txt", "///foo.txt", "/../../foo.txt"}
-	for _, path := range paths {
-		req, err := ReadRequest(bufio.NewReader(strings.NewReader("GET " + path + " HTTP/1.1\r\nHost: test\r\n\r\n")))
-		if err != nil {
-			t.Errorf("%s", err)
-		}
-		mux := NewServeMux()
-		resp := httptest.NewRecorder()
-
-		mux.ServeHTTP(resp, req)
-
-		if loc, expected := resp.Header().Get("Location"), "/foo.txt"; loc != expected {
-			t.Errorf("Expected Location header set to %q; got %q", expected, loc)
-			return
-		}
-
-		if code, expected := resp.Code, StatusMovedPermanently; code != expected {
-			t.Errorf("Expected response code of StatusMovedPermanently; got %d", code)
-			return
-		}
-	}
-}
-
-func TestServerTimeouts(t *testing.T) {
-	if runtime.GOOS == "plan9" {
-		t.Skip("skipping test; see http://golang.org/issue/7237")
-	}
-	defer afterTest(t)
-	reqNum := 0
-	ts := httptest.NewUnstartedServer(HandlerFunc(func(res ResponseWriter, req *Request) {
-		reqNum++
-		fmt.Fprintf(res, "req=%d", reqNum)
-	}))
-	ts.Config.ReadTimeout = 250 * time.Millisecond
-	ts.Config.WriteTimeout = 250 * time.Millisecond
-	ts.Start()
-	defer ts.Close()
-
-	// Hit the HTTP server successfully.
-	tr := &Transport{DisableKeepAlives: true} // they interfere with this test
-	defer tr.CloseIdleConnections()
-	c := &Client{Transport: tr}
-	r, err := c.Get(ts.URL)
-	if err != nil {
-		t.Fatalf("http Get #1: %v", err)
-	}
-	got, _ := ioutil.ReadAll(r.Body)
-	expected := "req=1"
-	if string(got) != expected {
-		t.Errorf("Unexpected response for request #1; got %q; expected %q",
-			string(got), expected)
-	}
-
-	// Slow client that should timeout.
-	t1 := time.Now()
-	conn, err := net.Dial("tcp", ts.Listener.Addr().String())
-	if err != nil {
-		t.Fatalf("Dial: %v", err)
-	}
-	buf := make([]byte, 1)
-	n, err := conn.Read(buf)
-	latency := time.Since(t1)
-	if n != 0 || err != io.EOF {
-		t.Errorf("Read = %v, %v, wanted %v, %v", n, err, 0, io.EOF)
-	}
-	if latency < 200*time.Millisecond /* fudge from 250 ms above */ {
-		t.Errorf("got EOF after %s, want >= %s", latency, 200*time.Millisecond)
-	}
-
-	// Hit the HTTP server successfully again, verifying that the
-	// previous slow connection didn't run our handler.  (that we
-	// get "req=2", not "req=3")
-	r, err = Get(ts.URL)
-	if err != nil {
-		t.Fatalf("http Get #2: %v", err)
-	}
-	got, _ = ioutil.ReadAll(r.Body)
-	expected = "req=2"
-	if string(got) != expected {
-		t.Errorf("Get #2 got %q, want %q", string(got), expected)
-	}
-
-	if !testing.Short() {
-		conn, err := net.Dial("tcp", ts.Listener.Addr().String())
-		if err != nil {
-			t.Fatalf("Dial: %v", err)
-		}
-		defer conn.Close()
-		go io.Copy(ioutil.Discard, conn)
-		for i := 0; i < 5; i++ {
-			_, err := conn.Write([]byte("GET / HTTP/1.1\r\nHost: foo\r\n\r\n"))
-			if err != nil {
-				t.Fatalf("on write %d: %v", i, err)
-			}
-			time.Sleep(ts.Config.ReadTimeout / 2)
-		}
-	}
-}
-
-// golang.org/issue/4741 -- setting only a write timeout that triggers
-// shouldn't cause a handler to block forever on reads (next HTTP
-// request) that will never happen.
-func TestOnlyWriteTimeout(t *testing.T) {
-	if runtime.GOOS == "plan9" {
-		t.Skip("skipping test; see http://golang.org/issue/7237")
-	}
-	defer afterTest(t)
-	var conn net.Conn
-	var afterTimeoutErrc = make(chan error, 1)
-	ts := httptest.NewUnstartedServer(HandlerFunc(func(w ResponseWriter, req *Request) {
-		buf := make([]byte, 512<<10)
-		_, err := w.Write(buf)
-		if err != nil {
-			t.Errorf("handler Write error: %v", err)
-			return
-		}
-		conn.SetWriteDeadline(time.Now().Add(-30 * time.Second))
-		_, err = w.Write(buf)
-		afterTimeoutErrc <- err
-	}))
-	ts.Listener = trackLastConnListener{ts.Listener, &conn}
-	ts.Start()
-	defer ts.Close()
-
-	tr := &Transport{DisableKeepAlives: false}
-	defer tr.CloseIdleConnections()
-	c := &Client{Transport: tr}
-
-	errc := make(chan error)
-	go func() {
-		res, err := c.Get(ts.URL)
-		if err != nil {
-			errc <- err
-			return
-		}
-		_, err = io.Copy(ioutil.Discard, res.Body)
-		errc <- err
-	}()
-	select {
-	case err := <-errc:
-		if err == nil {
-			t.Errorf("expected an error from Get request")
-		}
-	case <-time.After(5 * time.Second):
-		t.Fatal("timeout waiting for Get error")
-	}
-	if err := <-afterTimeoutErrc; err == nil {
-		t.Error("expected write error after timeout")
-	}
-}
-
-// trackLastConnListener tracks the last net.Conn that was accepted.
-type trackLastConnListener struct {
-	net.Listener
-	last *net.Conn // destination
-}
-
-func (l trackLastConnListener) Accept() (c net.Conn, err error) {
-	c, err = l.Listener.Accept()
-	*l.last = c
-	return
-}
-
-// TestIdentityResponse verifies that a handler can unset
-func TestIdentityResponse(t *testing.T) {
-	defer afterTest(t)
-	handler := HandlerFunc(func(rw ResponseWriter, req *Request) {
-		rw.Header().Set("Content-Length", "3")
-		rw.Header().Set("Transfer-Encoding", req.FormValue("te"))
-		switch {
-		case req.FormValue("overwrite") == "1":
-			_, err := rw.Write([]byte("foo TOO LONG"))
-			if err != ErrContentLength {
-				t.Errorf("expected ErrContentLength; got %v", err)
-			}
-		case req.FormValue("underwrite") == "1":
-			rw.Header().Set("Content-Length", "500")
-			rw.Write([]byte("too short"))
-		default:
-			rw.Write([]byte("foo"))
-		}
-	})
-
-	ts := httptest.NewServer(handler)
-	defer ts.Close()
-
-	// Note: this relies on the assumption (which is true) that
-	// Get sends HTTP/1.1 or greater requests.  Otherwise the
-	// server wouldn't have the choice to send back chunked
-	// responses.
-	for _, te := range []string{"", "identity"} {
-		url := ts.URL + "/?te=" + te
-		res, err := Get(url)
-		if err != nil {
-			t.Fatalf("error with Get of %s: %v", url, err)
-		}
-		if cl, expected := res.ContentLength, int64(3); cl != expected {
-			t.Errorf("for %s expected res.ContentLength of %d; got %d", url, expected, cl)
-		}
-		if cl, expected := res.Header.Get("Content-Length"), "3"; cl != expected {
-			t.Errorf("for %s expected Content-Length header of %q; got %q", url, expected, cl)
-		}
-		if tl, expected := len(res.TransferEncoding), 0; tl != expected {
-			t.Errorf("for %s expected len(res.TransferEncoding) of %d; got %d (%v)",
-				url, expected, tl, res.TransferEncoding)
-		}
-		res.Body.Close()
-	}
-
-	// Verify that ErrContentLength is returned
-	url := ts.URL + "/?overwrite=1"
-	res, err := Get(url)
-	if err != nil {
-		t.Fatalf("error with Get of %s: %v", url, err)
-	}
-	res.Body.Close()
-
-	// Verify that the connection is closed when the declared Content-Length
-	// is larger than what the handler wrote.
-	conn, err := net.Dial("tcp", ts.Listener.Addr().String())
-	if err != nil {
-		t.Fatalf("error dialing: %v", err)
-	}
-	_, err = conn.Write([]byte("GET /?underwrite=1 HTTP/1.1\r\nHost: foo\r\n\r\n"))
-	if err != nil {
-		t.Fatalf("error writing: %v", err)
-	}
-
-	// The ReadAll will hang for a failing test, so use a Timer to
-	// fail explicitly.
-	goTimeout(t, 2*time.Second, func() {
-		got, _ := ioutil.ReadAll(conn)
-		expectedSuffix := "\r\n\r\ntoo short"
-		if !strings.HasSuffix(string(got), expectedSuffix) {
-			t.Errorf("Expected output to end with %q; got response body %q",
-				expectedSuffix, string(got))
-		}
-	})
-}
-
-func testTCPConnectionCloses(t *testing.T, req string, h Handler) {
-	defer afterTest(t)
-	s := httptest.NewServer(h)
-	defer s.Close()
-
-	conn, err := net.Dial("tcp", s.Listener.Addr().String())
-	if err != nil {
-		t.Fatal("dial error:", err)
-	}
-	defer conn.Close()
-
-	_, err = fmt.Fprint(conn, req)
-	if err != nil {
-		t.Fatal("print error:", err)
-	}
-
-	r := bufio.NewReader(conn)
-	res, err := ReadResponse(r, &Request{Method: "GET"})
-	if err != nil {
-		t.Fatal("ReadResponse error:", err)
-	}
-
-	didReadAll := make(chan bool, 1)
-	go func() {
-		select {
-		case <-time.After(5 * time.Second):
-			t.Error("body not closed after 5s")
-			return
-		case <-didReadAll:
-		}
-	}()
-
-	_, err = ioutil.ReadAll(r)
-	if err != nil {
-		t.Fatal("read error:", err)
-	}
-	didReadAll <- true
-
-	if !res.Close {
-		t.Errorf("Response.Close = false; want true")
-	}
-}
-
-// TestServeHTTP10Close verifies that HTTP/1.0 requests won't be kept alive.
-func TestServeHTTP10Close(t *testing.T) {
-	testTCPConnectionCloses(t, "GET / HTTP/1.0\r\n\r\n", HandlerFunc(func(w ResponseWriter, r *Request) {
-		ServeFile(w, r, "testdata/file")
-	}))
-}
-
-// TestClientCanClose verifies that clients can also force a connection to close.
-func TestClientCanClose(t *testing.T) {
-	testTCPConnectionCloses(t, "GET / HTTP/1.1\r\nConnection: close\r\n\r\n", HandlerFunc(func(w ResponseWriter, r *Request) {
-		// Nothing.
-	}))
-}
-
-// TestHandlersCanSetConnectionClose verifies that handlers can force a connection to close,
-// even for HTTP/1.1 requests.
-func TestHandlersCanSetConnectionClose11(t *testing.T) {
-	testTCPConnectionCloses(t, "GET / HTTP/1.1\r\n\r\n", HandlerFunc(func(w ResponseWriter, r *Request) {
-		w.Header().Set("Connection", "close")
-	}))
-}
-
-func TestHandlersCanSetConnectionClose10(t *testing.T) {
-	testTCPConnectionCloses(t, "GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n", HandlerFunc(func(w ResponseWriter, r *Request) {
-		w.Header().Set("Connection", "close")
-	}))
-}
-
-func TestSetsRemoteAddr(t *testing.T) {
-	defer afterTest(t)
-	ts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {
-		fmt.Fprintf(w, "%s", r.RemoteAddr)
-	}))
-	defer ts.Close()
-
-	res, err := Get(ts.URL)
-	if err != nil {
-		t.Fatalf("Get error: %v", err)
-	}
-	body, err := ioutil.ReadAll(res.Body)
-	if err != nil {
-		t.Fatalf("ReadAll error: %v", err)
-	}
-	ip := string(body)
-	if !strings.HasPrefix(ip, "127.0.0.1:") && !strings.HasPrefix(ip, "[::1]:") {
-		t.Fatalf("Expected local addr; got %q", ip)
-	}
-}
-
-func TestChunkedResponseHeaders(t *testing.T) {
-	defer afterTest(t)
-	log.SetOutput(ioutil.Discard) // is noisy otherwise
-	defer log.SetOutput(os.Stderr)
-
-	ts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {
-		w.Header().Set("Content-Length", "intentional gibberish") // we check that this is deleted
-		w.(Flusher).Flush()
-		fmt.Fprintf(w, "I am a chunked response.")
-	}))
-	defer ts.Close()
-
-	res, err := Get(ts.URL)
-	if err != nil {
-		t.Fatalf("Get error: %v", err)
-	}
-	defer res.Body.Close()
-	if g, e := res.ContentLength, int64(-1); g != e {
-		t.Errorf("expected ContentLength of %d; got %d", e, g)
-	}
-	if g, e := res.TransferEncoding, []string{"chunked"}; !reflect.DeepEqual(g, e) {
-		t.Errorf("expected TransferEncoding of %v; got %v", e, g)
-	}
-	if _, haveCL := res.Header["Content-Length"]; haveCL {
-		t.Errorf("Unexpected Content-Length")
-	}
-}
-
-// Test304Responses verifies that 304s don't declare that they're
-// chunking in their response headers and aren't allowed to produce
-// output.
-func Test304Responses(t *testing.T) {
-	defer afterTest(t)
-	ts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {
-		w.WriteHeader(StatusNotModified)
-		_, err := w.Write([]byte("illegal body"))
-		if err != ErrBodyNotAllowed {
-			t.Errorf("on Write, expected ErrBodyNotAllowed, got %v", err)
-		}
-	}))
-	defer ts.Close()
-	res, err := Get(ts.URL)
-	if err != nil {
-		t.Error(err)
-	}
-	if len(res.TransferEncoding) > 0 {
-		t.Errorf("expected no TransferEncoding; got %v", res.TransferEncoding)
-	}
-	body, err := ioutil.ReadAll(res.Body)
-	if err != nil {
-		t.Error(err)
-	}
-	if len(body) > 0 {
-		t.Errorf("got unexpected body %q", string(body))
-	}
-}
-
-// TestHeadResponses verifies that all MIME type sniffing and Content-Length
-// counting of GET requests also happens on HEAD requests.
-func TestHeadResponses(t *testing.T) {
-	defer afterTest(t)
-	ts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {
-		_, err := w.Write([]byte("<html>"))
-		if err != nil {
-			t.Errorf("ResponseWriter.Write: %v", err)
-		}
-
-		// Also exercise the ReaderFrom path
-		_, err = io.Copy(w, strings.NewReader("789a"))
-		if err != nil {
-			t.Errorf("Copy(ResponseWriter, ...): %v", err)
-		}
-	}))
-	defer ts.Close()
-	res, err := Head(ts.URL)
-	if err != nil {
-		t.Error(err)
-	}
-	if len(res.TransferEncoding) > 0 {
-		t.Errorf("expected no TransferEncoding; got %v", res.TransferEncoding)
-	}
-	if ct := res.Header.Get("Content-Type"); ct != "text/html; charset=utf-8" {
-		t.Errorf("Content-Type: %q; want text/html; charset=utf-8", ct)
-	}
-	if v := res.ContentLength; v != 10 {
-		t.Errorf("Content-Length: %d; want 10", v)
-	}
-	body, err := ioutil.ReadAll(res.Body)
-	if err != nil {
-		t.Error(err)
-	}
-	if len(body) > 0 {
-		t.Errorf("got unexpected body %q", string(body))
-	}
-}
-
-func TestTLSHandshakeTimeout(t *testing.T) {
-	if runtime.GOOS == "plan9" {
-		t.Skip("skipping test; see http://golang.org/issue/7237")
-	}
-	defer afterTest(t)
-	ts := httptest.NewUnstartedServer(HandlerFunc(func(w ResponseWriter, r *Request) {}))
-	errc := make(chanWriter, 10) // but only expecting 1
-	ts.Config.ReadTimeout = 250 * time.Millisecond
-	ts.Config.ErrorLog = log.New(errc, "", 0)
-	ts.StartTLS()
-	defer ts.Close()
-	conn, err := net.Dial("tcp", ts.Listener.Addr().String())
-	if err != nil {
-		t.Fatalf("Dial: %v", err)
-	}
-	defer conn.Close()
-	goTimeout(t, 10*time.Second, func() {
-		var buf [1]byte
-		n, err := conn.Read(buf[:])
-		if err == nil || n != 0 {
-			t.Errorf("Read = %d, %v; want an error and no bytes", n, err)
-		}
-	})
-	select {
-	case v := <-errc:
-		if !strings.Contains(v, "timeout") && !strings.Contains(v, "TLS handshake") {
-			t.Errorf("expected a TLS handshake timeout error; got %q", v)
-		}
-	case <-time.After(5 * time.Second):
-		t.Errorf("timeout waiting for logged error")
-	}
-}
-
-func TestTLSServer(t *testing.T) {
-	defer afterTest(t)
-	ts := httptest.NewTLSServer(HandlerFunc(func(w ResponseWriter, r *Request) {
-		if r.TLS != nil {
-			w.Header().Set("X-TLS-Set", "true")
-			if r.TLS.HandshakeComplete {
-				w.Header().Set("X-TLS-HandshakeComplete", "true")
-			}
-		}
-	}))
-	ts.Config.ErrorLog = log.New(ioutil.Discard, "", 0)
-	defer ts.Close()
-
-	// Connect an idle TCP connection to this server before we run
-	// our real tests.  This idle connection used to block forever
-	// in the TLS handshake, preventing future connections from
-	// being accepted. It may prevent future accidental blocking
-	// in newConn.
-	idleConn, err := net.Dial("tcp", ts.Listener.Addr().String())
-	if err != nil {
-		t.Fatalf("Dial: %v", err)
-	}
-	defer idleConn.Close()
-	goTimeout(t, 10*time.Second, func() {
-		if !strings.HasPrefix(ts.URL, "https://") {
-			t.Errorf("expected test TLS server to start with https://, got %q", ts.URL)
-			return
-		}
-		noVerifyTransport := &Transport{
-			TLSClientConfig: &tls.Config{
-				InsecureSkipVerify: true,
-			},
-		}
-		client := &Client{Transport: noVerifyTransport}
-		res, err := client.Get(ts.URL)
-		if err != nil {
-			t.Error(err)
-			return
-		}
-		if res == nil {
-			t.Errorf("got nil Response")
-			return
-		}
-		defer res.Body.Close()
-		if res.Header.Get("X-TLS-Set") != "true" {
-			t.Errorf("expected X-TLS-Set response header")
-			return
-		}
-		if res.Header.Get("X-TLS-HandshakeComplete") != "true" {
-			t.Errorf("expected X-TLS-HandshakeComplete header")
-		}
-	})
-}
-
-type serverExpectTest struct {
-	contentLength    int // of request body
-	chunked          bool
-	expectation      string // e.g. "100-continue"
-	readBody         bool   // whether handler should read the body (if false, sends StatusUnauthorized)
-	expectedResponse string // expected substring in first line of http response
-}
-
-func expectTest(contentLength int, expectation string, readBody bool, expectedResponse string) serverExpectTest {
-	return serverExpectTest{
-		contentLength:    contentLength,
-		expectation:      expectation,
-		readBody:         readBody,
-		expectedResponse: expectedResponse,
-	}
-}
-
-var serverExpectTests = []serverExpectTest{
-	// Normal 100-continues, case-insensitive.
-	expectTest(100, "100-continue", true, "100 Continue"),
-	expectTest(100, "100-cOntInUE", true, "100 Continue"),
-
-	// No 100-continue.
-	expectTest(100, "", true, "200 OK"),
-
-	// 100-continue but requesting client to deny us,
-	// so it never reads the body.
-	expectTest(100, "100-continue", false, "401 Unauthorized"),
-	// Likewise without 100-continue:
-	expectTest(100, "", false, "401 Unauthorized"),
-
-	// Non-standard expectations are failures
-	expectTest(0, "a-pony", false, "417 Expectation Failed"),
-
-	// Expect-100 requested but no body (is apparently okay: Issue 7625)
-	expectTest(0, "100-continue", true, "200 OK"),
-	// Expect-100 requested but handler doesn't read the body
-	expectTest(0, "100-continue", false, "401 Unauthorized"),
-	// Expect-100 continue with no body, but a chunked body.
-	{
-		expectation:      "100-continue",
-		readBody:         true,
-		chunked:          true,
-		expectedResponse: "100 Continue",
-	},
-}
-
-// Tests that the server responds to the "Expect" request header
-// correctly.
-func TestServerExpect(t *testing.T) {
-	defer afterTest(t)
-	ts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {
-		// Note using r.FormValue("readbody") because for POST
-		// requests that would read from r.Body, which we only
-		// conditionally want to do.
-		if strings.Contains(r.URL.RawQuery, "readbody=true") {
-			ioutil.ReadAll(r.Body)
-			w.Write([]byte("Hi"))
-		} else {
-			w.WriteHeader(StatusUnauthorized)
-		}
-	}))
-	defer ts.Close()
-
-	runTest := func(test serverExpectTest) {
-		conn, err := net.Dial("tcp", ts.Listener.Addr().String())
-		if err != nil {
-			t.Fatalf("Dial: %v", err)
-		}
-		defer conn.Close()
-
-		// Only send the body immediately if we're acting like an HTTP client
-		// that doesn't send 100-continue expectations.
-		writeBody := test.contentLength != 0 && strings.ToLower(test.expectation) != "100-continue"
-
-		go func() {
-			contentLen := fmt.Sprintf("Content-Length: %d", test.contentLength)
-			if test.chunked {
-				contentLen = "Transfer-Encoding: chunked"
-			}
-			_, err := fmt.Fprintf(conn, "POST /?readbody=%v HTTP/1.1\r\n"+
-				"Connection: close\r\n"+
-				"%s\r\n"+
-				"Expect: %s\r\nHost: foo\r\n\r\n",
-				test.readBody, contentLen, test.expectation)
-			if err != nil {
-				t.Errorf("On test %#v, error writing request headers: %v", test, err)
-				return
-			}
-			if writeBody {
-				var targ io.WriteCloser = struct {
-					io.Writer
-					io.Closer
-				}{
-					conn,
-					ioutil.NopCloser(nil),
-				}
-				if test.chunked {
-					targ = httputil.NewChunkedWriter(conn)
-				}
-				body := strings.Repeat("A", test.contentLength)
-				_, err = fmt.Fprint(targ, body)
-				if err == nil {
-					err = targ.Close()
-				}
-				if err != nil {
-					if !test.readBody {
-						// Server likely already hung up on us.
-						// See larger comment below.
-						t.Logf("On test %#v, acceptable error writing request body: %v", test, err)
-						return
-					}
-					t.Errorf("On test %#v, error writing request body: %v", test, err)
-				}
-			}
-		}()
-		bufr := bufio.NewReader(conn)
-		line, err := bufr.ReadString('\n')
-		if err != nil {
-			if writeBody && !test.readBody {
-				// This is an acceptable failure due to a possible TCP race:
-				// We were still writing data and the server hung up on us. A TCP
-				// implementation may send a RST if our request body data was known
-				// to be lost, which may trigger our reads to fail.
-				// See RFC 1122 page 88.
-				t.Logf("On test %#v, acceptable error from ReadString: %v", test, err)
-				return
-			}
-			t.Fatalf("On test %#v, ReadString: %v", test, err)
-		}
-		if !strings.Contains(line, test.expectedResponse) {
-			t.Errorf("On test %#v, got first line = %q; want %q", test, line, test.expectedResponse)
-		}
-	}
-
-	for _, test := range serverExpectTests {
-		runTest(test)
-	}
-}
-
-// Under a ~256KB (maxPostHandlerReadBytes) threshold, the server
-// should consume client request bodies that a handler didn't read.
-func TestServerUnreadRequestBodyLittle(t *testing.T) {
-	conn := new(testConn)
-	body := strings.Repeat("x", 100<<10)
-	conn.readBuf.Write([]byte(fmt.Sprintf(
-		"POST / HTTP/1.1\r\n"+
-			"Host: test\r\n"+
-			"Content-Length: %d\r\n"+
-			"\r\n", len(body))))
-	conn.readBuf.Write([]byte(body))
-
-	done := make(chan bool)
-
-	ls := &oneConnListener{conn}
-	go Serve(ls, HandlerFunc(func(rw ResponseWriter, req *Request) {
-		defer close(done)
-		if conn.readBuf.Len() < len(body)/2 {
-			t.Errorf("on request, read buffer length is %d; expected about 100 KB", conn.readBuf.Len())
-		}
-		rw.WriteHeader(200)
-		rw.(Flusher).Flush()
-		if g, e := conn.readBuf.Len(), 0; g != e {
-			t.Errorf("after WriteHeader, read buffer length is %d; want %d", g, e)
-		}
-		if c := rw.Header().Get("Connection"); c != "" {
-			t.Errorf(`Connection header = %q; want ""`, c)
-		}
-	}))
-	<-done
-}
-
-// Over a ~256KB (maxPostHandlerReadBytes) threshold, the server
-// should ignore client request bodies that a handler didn't read
-// and close the connection.
-func TestServerUnreadRequestBodyLarge(t *testing.T) {
-	conn := new(testConn)
-	body := strings.Repeat("x", 1<<20)
-	conn.readBuf.Write([]byte(fmt.Sprintf(
-		"POST / HTTP/1.1\r\n"+
-			"Host: test\r\n"+
-			"Content-Length: %d\r\n"+
-			"\r\n", len(body))))
-	conn.readBuf.Write([]byte(body))
-	conn.closec = make(chan bool, 1)
-
-	ls := &oneConnListener{conn}
-	go Serve(ls, HandlerFunc(func(rw ResponseWriter, req *Request) {
-		if conn.readBuf.Len() < len(body)/2 {
-			t.Errorf("on request, read buffer length is %d; expected about 1MB", conn.readBuf.Len())
-		}
-		rw.WriteHeader(200)
-		rw.(Flusher).Flush()
-		if conn.readBuf.Len() < len(body)/2 {
-			t.Errorf("post-WriteHeader, read buffer length is %d; expected about 1MB", conn.readBuf.Len())
-		}
-	}))
-	<-conn.closec
-
-	if res := conn.writeBuf.String(); !strings.Contains(res, "Connection: close") {
-		t.Errorf("Expected a Connection: close header; got response: %s", res)
-	}
-}
-
-func TestTimeoutHandler(t *testing.T) {
-	defer afterTest(t)
-	sendHi := make(chan bool, 1)
-	writeErrors := make(chan error, 1)
-	sayHi := HandlerFunc(func(w ResponseWriter, r *Request) {
-		<-sendHi
-		_, werr := w.Write([]byte("hi"))
-		writeErrors <- werr
-	})
-	timeout := make(chan time.Time, 1) // write to this to force timeouts
-	ts := httptest.NewServer(NewTestTimeoutHandler(sayHi, timeout))
-	defer ts.Close()
-
-	// Succeed without timing out:
-	sendHi <- true
-	res, err := Get(ts.URL)
-	if err != nil {
-		t.Error(err)
-	}
-	if g, e := res.StatusCode, StatusOK; g != e {
-		t.Errorf("got res.StatusCode %d; expected %d", g, e)
-	}
-	body, _ := ioutil.ReadAll(res.Body)
-	if g, e := string(body), "hi"; g != e {
-		t.Errorf("got body %q; expected %q", g, e)
-	}
-	if g := <-writeErrors; g != nil {
-		t.Errorf("got unexpected Write error on first request: %v", g)
-	}
-
-	// Times out:
-	timeout <- time.Time{}
-	res, err = Get(ts.URL)
-	if err != nil {
-		t.Error(err)
-	}
-	if g, e := res.StatusCode, StatusServiceUnavailable; g != e {
-		t.Errorf("got res.StatusCode %d; expected %d", g, e)
-	}
-	body, _ = ioutil.ReadAll(res.Body)
-	if !strings.Contains(string(body), "<title>Timeout</title>") {
-		t.Errorf("expected timeout body; got %q", string(body))
-	}
-
-	// Now make the previously-timed out handler speak again,
-	// which verifies the panic is handled:
-	sendHi <- true
-	if g, e := <-writeErrors, ErrHandlerTimeout; g != e {
-		t.Errorf("expected Write error of %v; got %v", e, g)
-	}
-}
-
-// Verifies we don't path.Clean() on the wrong parts in redirects.
-func TestRedirectMunging(t *testing.T) {
-	req, _ := NewRequest("GET", "http://example.com/", nil)
-
-	resp := httptest.NewRecorder()
-	Redirect(resp, req, "/foo?next=http://bar.com/", 302)
-	if g, e := resp.Header().Get("Location"), "/foo?next=http://bar.com/"; g != e {
-		t.Errorf("Location header was %q; want %q", g, e)
-	}
-
-	resp = httptest.NewRecorder()
-	Redirect(resp, req, "http://localhost:8080/_ah/login?continue=http://localhost:8080/", 302)
-	if g, e := resp.Header().Get("Location"), "http://localhost:8080/_ah/login?continue=http://localhost:8080/"; g != e {
-		t.Errorf("Location header was %q; want %q", g, e)
-	}
-}
-
-func TestRedirectBadPath(t *testing.T) {
-	// This used to crash. It's not valid input (bad path), but it
-	// shouldn't crash.
-	rr := httptest.NewRecorder()
-	req := &Request{
-		Method: "GET",
-		URL: &url.URL{
-			Scheme: "http",
-			Path:   "not-empty-but-no-leading-slash", // bogus
-		},
-	}
-	Redirect(rr, req, "", 304)
-	if rr.Code != 304 {
-		t.Errorf("Code = %d; want 304", rr.Code)
-	}
-}
-
-// TestZeroLengthPostAndResponse exercises an optimization done by the Transport:
-// when there is no body (either because the method doesn't permit a body, or an
-// explicit Content-Length of zero is present), then the transport can re-use the
-// connection immediately. But when it re-uses the connection, it typically closes
-// the previous request's body, which is not optimal for zero-lengthed bodies,
-// as the client would then see http.ErrBodyReadAfterClose and not 0, io.EOF.
-func TestZeroLengthPostAndResponse(t *testing.T) {
-	defer afterTest(t)
-	ts := httptest.NewServer(HandlerFunc(func(rw ResponseWriter, r *Request) {
-		all, err := ioutil.ReadAll(r.Body)
-		if err != nil {
-			t.Fatalf("handler ReadAll: %v", err)
-		}
-		if len(all) != 0 {
-			t.Errorf("handler got %d bytes; expected 0", len(all))
-		}
-		rw.Header().Set("Content-Length", "0")
-	}))
-	defer ts.Close()
-
-	req, err := NewRequest("POST", ts.URL, strings.NewReader(""))
-	if err != nil {
-		t.Fatal(err)
-	}
-	req.ContentLength = 0
-
-	var resp [5]*Response
-	for i := range resp {
-		resp[i], err = DefaultClient.Do(req)
-		if err != nil {
-			t.Fatalf("client post #%d: %v", i, err)
-		}
-	}
-
-	for i := range resp {
-		all, err := ioutil.ReadAll(resp[i].Body)
-		if err != nil {
-			t.Fatalf("req #%d: client ReadAll: %v", i, err)
-		}
-		if len(all) != 0 {
-			t.Errorf("req #%d: client got %d bytes; expected 0", i, len(all))
-		}
-	}
-}
-
-func TestHandlerPanicNil(t *testing.T) {
-	testHandlerPanic(t, false, nil)
-}
-
-func TestHandlerPanic(t *testing.T) {
-	testHandlerPanic(t, false, "intentional death for testing")
-}
-
-func TestHandlerPanicWithHijack(t *testing.T) {
-	testHandlerPanic(t, true, "intentional death for testing")
-}
-
-func testHandlerPanic(t *testing.T, withHijack bool, panicValue interface{}) {
-	defer afterTest(t)
-	// Unlike the other tests that set the log output to ioutil.Discard
-	// to quiet the output, this test uses a pipe.  The pipe serves three
-	// purposes:
-	//
-	//   1) The log.Print from the http server (generated by the caught
-	//      panic) will go to the pipe instead of stderr, making the
-	//      output quiet.
-	//
-	//   2) We read from the pipe to verify that the handler
-	//      actually caught the panic and logged something.
-	//
-	//   3) The blocking Read call prevents this TestHandlerPanic
-	//      function from exiting before the HTTP server handler
-	//      finishes crashing. If this text function exited too
-	//      early (and its defer log.SetOutput(os.Stderr) ran),
-	//      then the crash output could spill into the next test.
-	pr, pw := io.Pipe()
-	log.SetOutput(pw)
-	defer log.SetOutput(os.Stderr)
-	defer pw.Close()
-
-	ts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {
-		if withHijack {
-			rwc, _, err := w.(Hijacker).Hijack()
-			if err != nil {
-				t.Logf("unexpected error: %v", err)
-			}
-			defer rwc.Close()
-		}
-		panic(panicValue)
-	}))
-	defer ts.Close()
-
-	// Do a blocking read on the log output pipe so its logging
-	// doesn't bleed into the next test.  But wait only 5 seconds
-	// for it.
-	done := make(chan bool, 1)
-	go func() {
-		buf := make([]byte, 4<<10)
-		_, err := pr.Read(buf)
-		pr.Close()
-		if err != nil && err != io.EOF {
-			t.Error(err)
-		}
-		done <- true
-	}()
-
-	_, err := Get(ts.URL)
-	if err == nil {
-		t.Logf("expected an error")
-	}
-
-	if panicValue == nil {
-		return
-	}
-
-	select {
-	case <-done:
-		return
-	case <-time.After(5 * time.Second):
-		t.Fatal("expected server handler to log an error")
-	}
-}
-
-func TestNoDate(t *testing.T) {
-	defer afterTest(t)
-	ts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {
-		w.Header()["Date"] = nil
-	}))
-	defer ts.Close()
-	res, err := Get(ts.URL)
-	if err != nil {
-		t.Fatal(err)
-	}
-	_, present := res.Header["Date"]
-	if present {
-		t.Fatalf("Expected no Date header; got %v", res.Header["Date"])
-	}
-}
-
-func TestStripPrefix(t *testing.T) {
-	defer afterTest(t)
-	h := HandlerFunc(func(w ResponseWriter, r *Request) {
-		w.Header().Set("X-Path", r.URL.Path)
-	})
-	ts := httptest.NewServer(StripPrefix("/foo", h))
-	defer ts.Close()
-
-	res, err := Get(ts.URL + "/foo/bar")
-	if err != nil {
-		t.Fatal(err)
-	}
-	if g, e := res.Header.Get("X-Path"), "/bar"; g != e {
-		t.Errorf("test 1: got %s, want %s", g, e)
-	}
-	res.Body.Close()
-
-	res, err = Get(ts.URL + "/bar")
-	if err != nil {
-		t.Fatal(err)
-	}
-	if g, e := res.StatusCode, 404; g != e {
-		t.Errorf("test 2: got status %v, want %v", g, e)
-	}
-	res.Body.Close()
-}
-
-func TestRequestLimit(t *testing.T) {
-	defer afterTest(t)
-	ts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {
-		t.Fatalf("didn't expect to get request in Handler")
-	}))
-	defer ts.Close()
-	req, _ := NewRequest("GET", ts.URL, nil)
-	var bytesPerHeader = len("header12345: val12345\r\n")
-	for i := 0; i < ((DefaultMaxHeaderBytes+4096)/bytesPerHeader)+1; i++ {
-		req.Header.Set(fmt.Sprintf("header%05d", i), fmt.Sprintf("val%05d", i))
-	}
-	res, err := DefaultClient.Do(req)
-	if err != nil {
-		// Some HTTP clients may fail on this undefined behavior (server replying and
-		// closing the connection while the request is still being written), but
-		// we do support it (at least currently), so we expect a response below.
-		t.Fatalf("Do: %v", err)
-	}
-	defer res.Body.Close()
-	if res.StatusCode != 413 {
-		t.Fatalf("expected 413 response status; got: %d %s", res.StatusCode, res.Status)
-	}
-}
-
 type neverEnding byte
 
 func (b neverEnding) Read(p []byte) (n int, err error) {
@@ -1420,1392 +56,3 @@
 	}
 	return len(p), nil
 }
-
-type countReader struct {
-	r io.Reader
-	n *int64
-}
-
-func (cr countReader) Read(p []byte) (n int, err error) {
-	n, err = cr.r.Read(p)
-	atomic.AddInt64(cr.n, int64(n))
-	return
-}
-
-func TestRequestBodyLimit(t *testing.T) {
-	defer afterTest(t)
-	const limit = 1 << 20
-	ts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {
-		r.Body = MaxBytesReader(w, r.Body, limit)
-		n, err := io.Copy(ioutil.Discard, r.Body)
-		if err == nil {
-			t.Errorf("expected error from io.Copy")
-		}
-		if n != limit {
-			t.Errorf("io.Copy = %d, want %d", n, limit)
-		}
-	}))
-	defer ts.Close()
-
-	nWritten := new(int64)
-	req, _ := NewRequest("POST", ts.URL, io.LimitReader(countReader{neverEnding('a'), nWritten}, limit*200))
-
-	// Send the POST, but don't care it succeeds or not.  The
-	// remote side is going to reply and then close the TCP
-	// connection, and HTTP doesn't really define if that's
-	// allowed or not.  Some HTTP clients will get the response
-	// and some (like ours, currently) will complain that the
-	// request write failed, without reading the response.
-	//
-	// But that's okay, since what we're really testing is that
-	// the remote side hung up on us before we wrote too much.
-	_, _ = DefaultClient.Do(req)
-
-	if atomic.LoadInt64(nWritten) > limit*100 {
-		t.Errorf("handler restricted the request body to %d bytes, but client managed to write %d",
-			limit, nWritten)
-	}
-}
-
-// TestClientWriteShutdown tests that if the client shuts down the write
-// side of their TCP connection, the server doesn't send a 400 Bad Request.
-func TestClientWriteShutdown(t *testing.T) {
-	if runtime.GOOS == "plan9" {
-		t.Skip("skipping test; see http://golang.org/issue/7237")
-	}
-	defer afterTest(t)
-	ts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {}))
-	defer ts.Close()
-	conn, err := net.Dial("tcp", ts.Listener.Addr().String())
-	if err != nil {
-		t.Fatalf("Dial: %v", err)
-	}
-	err = conn.(*net.TCPConn).CloseWrite()
-	if err != nil {
-		t.Fatalf("Dial: %v", err)
-	}
-	donec := make(chan bool)
-	go func() {
-		defer close(donec)
-		bs, err := ioutil.ReadAll(conn)
-		if err != nil {
-			t.Fatalf("ReadAll: %v", err)
-		}
-		got := string(bs)
-		if got != "" {
-			t.Errorf("read %q from server; want nothing", got)
-		}
-	}()
-	select {
-	case <-donec:
-	case <-time.After(10 * time.Second):
-		t.Fatalf("timeout")
-	}
-}
-
-// Tests that chunked server responses that write 1 byte at a time are
-// buffered before chunk headers are added, not after chunk headers.
-func TestServerBufferedChunking(t *testing.T) {
-	conn := new(testConn)
-	conn.readBuf.Write([]byte("GET / HTTP/1.1\r\n\r\n"))
-	conn.closec = make(chan bool, 1)
-	ls := &oneConnListener{conn}
-	go Serve(ls, HandlerFunc(func(rw ResponseWriter, req *Request) {
-		rw.(Flusher).Flush() // force the Header to be sent, in chunking mode, not counting the length
-		rw.Write([]byte{'x'})
-		rw.Write([]byte{'y'})
-		rw.Write([]byte{'z'})
-	}))
-	<-conn.closec
-	if !bytes.HasSuffix(conn.writeBuf.Bytes(), []byte("\r\n\r\n3\r\nxyz\r\n0\r\n\r\n")) {
-		t.Errorf("response didn't end with a single 3 byte 'xyz' chunk; got:\n%q",
-			conn.writeBuf.Bytes())
-	}
-}
-
-// Tests that the server flushes its response headers out when it's
-// ignoring the response body and waits a bit before forcefully
-// closing the TCP connection, causing the client to get a RST.
-// See http://golang.org/issue/3595
-func TestServerGracefulClose(t *testing.T) {
-	defer afterTest(t)
-	ts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {
-		Error(w, "bye", StatusUnauthorized)
-	}))
-	defer ts.Close()
-
-	conn, err := net.Dial("tcp", ts.Listener.Addr().String())
-	if err != nil {
-		t.Fatal(err)
-	}
-	defer conn.Close()
-	const bodySize = 5 << 20
-	req := []byte(fmt.Sprintf("POST / HTTP/1.1\r\nHost: foo.com\r\nContent-Length: %d\r\n\r\n", bodySize))
-	for i := 0; i < bodySize; i++ {
-		req = append(req, 'x')
-	}
-	writeErr := make(chan error)
-	go func() {
-		_, err := conn.Write(req)
-		writeErr <- err
-	}()
-	br := bufio.NewReader(conn)
-	lineNum := 0
-	for {
-		line, err := br.ReadString('\n')
-		if err == io.EOF {
-			break
-		}
-		if err != nil {
-			t.Fatalf("ReadLine: %v", err)
-		}
-		lineNum++
-		if lineNum == 1 && !strings.Contains(line, "401 Unauthorized") {
-			t.Errorf("Response line = %q; want a 401", line)
-		}
-	}
-	// Wait for write to finish. This is a broken pipe on both
-	// Darwin and Linux, but checking this isn't the point of
-	// the test.
-	<-writeErr
-}
-
-func TestCaseSensitiveMethod(t *testing.T) {
-	defer afterTest(t)
-	ts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {
-		if r.Method != "get" {
-			t.Errorf(`Got method %q; want "get"`, r.Method)
-		}
-	}))
-	defer ts.Close()
-	req, _ := NewRequest("get", ts.URL, nil)
-	res, err := DefaultClient.Do(req)
-	if err != nil {
-		t.Error(err)
-		return
-	}
-	res.Body.Close()
-}
-
-// TestContentLengthZero tests that for both an HTTP/1.0 and HTTP/1.1
-// request (both keep-alive), when a Handler never writes any
-// response, the net/http package adds a "Content-Length: 0" response
-// header.
-func TestContentLengthZero(t *testing.T) {
-	ts := httptest.NewServer(HandlerFunc(func(rw ResponseWriter, req *Request) {}))
-	defer ts.Close()
-
-	for _, version := range []string{"HTTP/1.0", "HTTP/1.1"} {
-		conn, err := net.Dial("tcp", ts.Listener.Addr().String())
-		if err != nil {
-			t.Fatalf("error dialing: %v", err)
-		}
-		_, err = fmt.Fprintf(conn, "GET / %v\r\nConnection: keep-alive\r\nHost: foo\r\n\r\n", version)
-		if err != nil {
-			t.Fatalf("error writing: %v", err)
-		}
-		req, _ := NewRequest("GET", "/", nil)
-		res, err := ReadResponse(bufio.NewReader(conn), req)
-		if err != nil {
-			t.Fatalf("error reading response: %v", err)
-		}
-		if te := res.TransferEncoding; len(te) > 0 {
-			t.Errorf("For version %q, Transfer-Encoding = %q; want none", version, te)
-		}
-		if cl := res.ContentLength; cl != 0 {
-			t.Errorf("For version %q, Content-Length = %v; want 0", version, cl)
-		}
-		conn.Close()
-	}
-}
-
-func TestCloseNotifier(t *testing.T) {
-	defer afterTest(t)
-	gotReq := make(chan bool, 1)
-	sawClose := make(chan bool, 1)
-	ts := httptest.NewServer(HandlerFunc(func(rw ResponseWriter, req *Request) {
-		gotReq <- true
-		cc := rw.(CloseNotifier).CloseNotify()
-		<-cc
-		sawClose <- true
-	}))
-	conn, err := net.Dial("tcp", ts.Listener.Addr().String())
-	if err != nil {
-		t.Fatalf("error dialing: %v", err)
-	}
-	diec := make(chan bool)
-	go func() {
-		_, err = fmt.Fprintf(conn, "GET / HTTP/1.1\r\nConnection: keep-alive\r\nHost: foo\r\n\r\n")
-		if err != nil {
-			t.Fatal(err)
-		}
-		<-diec
-		conn.Close()
-	}()
-For:
-	for {
-		select {
-		case <-gotReq:
-			diec <- true
-		case <-sawClose:
-			break For
-		case <-time.After(5 * time.Second):
-			t.Fatal("timeout")
-		}
-	}
-	ts.Close()
-}
-
-func TestCloseNotifierChanLeak(t *testing.T) {
-	defer afterTest(t)
-	req := reqBytes("GET / HTTP/1.0\nHost: golang.org")
-	for i := 0; i < 20; i++ {
-		var output bytes.Buffer
-		conn := &rwTestConn{
-			Reader: bytes.NewReader(req),
-			Writer: &output,
-			closec: make(chan bool, 1),
-		}
-		ln := &oneConnListener{conn: conn}
-		handler := HandlerFunc(func(rw ResponseWriter, r *Request) {
-			// Ignore the return value and never read from
-			// it, testing that we don't leak goroutines
-			// on the sending side:
-			_ = rw.(CloseNotifier).CloseNotify()
-		})
-		go Serve(ln, handler)
-		<-conn.closec
-	}
-}
-
-func TestOptions(t *testing.T) {
-	uric := make(chan string, 2) // only expect 1, but leave space for 2
-	mux := NewServeMux()
-	mux.HandleFunc("/", func(w ResponseWriter, r *Request) {
-		uric <- r.RequestURI
-	})
-	ts := httptest.NewServer(mux)
-	defer ts.Close()
-
-	conn, err := net.Dial("tcp", ts.Listener.Addr().String())
-	if err != nil {
-		t.Fatal(err)
-	}
-	defer conn.Close()
-
-	// An OPTIONS * request should succeed.
-	_, err = conn.Write([]byte("OPTIONS * HTTP/1.1\r\nHost: foo.com\r\n\r\n"))
-	if err != nil {
-		t.Fatal(err)
-	}
-	br := bufio.NewReader(conn)
-	res, err := ReadResponse(br, &Request{Method: "OPTIONS"})
-	if err != nil {
-		t.Fatal(err)
-	}
-	if res.StatusCode != 200 {
-		t.Errorf("Got non-200 response to OPTIONS *: %#v", res)
-	}
-
-	// A GET * request on a ServeMux should fail.
-	_, err = conn.Write([]byte("GET * HTTP/1.1\r\nHost: foo.com\r\n\r\n"))
-	if err != nil {
-		t.Fatal(err)
-	}
-	res, err = ReadResponse(br, &Request{Method: "GET"})
-	if err != nil {
-		t.Fatal(err)
-	}
-	if res.StatusCode != 400 {
-		t.Errorf("Got non-400 response to GET *: %#v", res)
-	}
-
-	res, err = Get(ts.URL + "/second")
-	if err != nil {
-		t.Fatal(err)
-	}
-	res.Body.Close()
-	if got := <-uric; got != "/second" {
-		t.Errorf("Handler saw request for %q; want /second", got)
-	}
-}
-
-// Tests regarding the ordering of Write, WriteHeader, Header, and
-// Flush calls.  In Go 1.0, rw.WriteHeader immediately flushed the
-// (*response).header to the wire. In Go 1.1, the actual wire flush is
-// delayed, so we could maybe tack on a Content-Length and better
-// Content-Type after we see more (or all) of the output. To preserve
-// compatibility with Go 1, we need to be careful to track which
-// headers were live at the time of WriteHeader, so we write the same
-// ones, even if the handler modifies them (~erroneously) after the
-// first Write.
-func TestHeaderToWire(t *testing.T) {
-	tests := []struct {
-		name    string
-		handler func(ResponseWriter, *Request)
-		check   func(output string) error
-	}{
-		{
-			name: "write without Header",
-			handler: func(rw ResponseWriter, r *Request) {
-				rw.Write([]byte("hello world"))
-			},
-			check: func(got string) error {
-				if !strings.Contains(got, "Content-Length:") {
-					return errors.New("no content-length")
-				}
-				if !strings.Contains(got, "Content-Type: text/plain") {
-					return errors.New("no content-length")
-				}
-				return nil
-			},
-		},
-		{
-			name: "Header mutation before write",
-			handler: func(rw ResponseWriter, r *Request) {
-				h := rw.Header()
-				h.Set("Content-Type", "some/type")
-				rw.Write([]byte("hello world"))
-				h.Set("Too-Late", "bogus")
-			},
-			check: func(got string) error {
-				if !strings.Contains(got, "Content-Length:") {
-					return errors.New("no content-length")
-				}
-				if !strings.Contains(got, "Content-Type: some/type") {
-					return errors.New("wrong content-type")
-				}
-				if strings.Contains(got, "Too-Late") {
-					return errors.New("don't want too-late header")
-				}
-				return nil
-			},
-		},
-		{
-			name: "write then useless Header mutation",
-			handler: func(rw ResponseWriter, r *Request) {
-				rw.Write([]byte("hello world"))
-				rw.Header().Set("Too-Late", "Write already wrote headers")
-			},
-			check: func(got string) error {
-				if strings.Contains(got, "Too-Late") {
-					return errors.New("header appeared from after WriteHeader")
-				}
-				return nil
-			},
-		},
-		{
-			name: "flush then write",
-			handler: func(rw ResponseWriter, r *Request) {
-				rw.(Flusher).Flush()
-				rw.Write([]byte("post-flush"))
-				rw.Header().Set("Too-Late", "Write already wrote headers")
-			},
-			check: func(got string) error {
-				if !strings.Contains(got, "Transfer-Encoding: chunked") {
-					return errors.New("not chunked")
-				}
-				if strings.Contains(got, "Too-Late") {
-					return errors.New("header appeared from after WriteHeader")
-				}
-				return nil
-			},
-		},
-		{
-			name: "header then flush",
-			handler: func(rw ResponseWriter, r *Request) {
-				rw.Header().Set("Content-Type", "some/type")
-				rw.(Flusher).Flush()
-				rw.Write([]byte("post-flush"))
-				rw.Header().Set("Too-Late", "Write already wrote headers")
-			},
-			check: func(got string) error {
-				if !strings.Contains(got, "Transfer-Encoding: chunked") {
-					return errors.New("not chunked")
-				}
-				if strings.Contains(got, "Too-Late") {
-					return errors.New("header appeared from after WriteHeader")
-				}
-				if !strings.Contains(got, "Content-Type: some/type") {
-					return errors.New("wrong content-length")
-				}
-				return nil
-			},
-		},
-		{
-			name: "sniff-on-first-write content-type",
-			handler: func(rw ResponseWriter, r *Request) {
-				rw.Write([]byte("<html><head></head><body>some html</body></html>"))
-				rw.Header().Set("Content-Type", "x/wrong")
-			},
-			check: func(got string) error {
-				if !strings.Contains(got, "Content-Type: text/html") {
-					return errors.New("wrong content-length; want html")
-				}
-				return nil
-			},
-		},
-		{
-			name: "explicit content-type wins",
-			handler: func(rw ResponseWriter, r *Request) {
-				rw.Header().Set("Content-Type", "some/type")
-				rw.Write([]byte("<html><head></head><body>some html</body></html>"))
-			},
-			check: func(got string) error {
-				if !strings.Contains(got, "Content-Type: some/type") {
-					return errors.New("wrong content-length; want html")
-				}
-				return nil
-			},
-		},
-		{
-			name: "empty handler",
-			handler: func(rw ResponseWriter, r *Request) {
-			},
-			check: func(got string) error {
-				if !strings.Contains(got, "Content-Type: text/plain") {
-					return errors.New("wrong content-length; want text/plain")
-				}
-				if !strings.Contains(got, "Content-Length: 0") {
-					return errors.New("want 0 content-length")
-				}
-				return nil
-			},
-		},
-		{
-			name: "only Header, no write",
-			handler: func(rw ResponseWriter, r *Request) {
-				rw.Header().Set("Some-Header", "some-value")
-			},
-			check: func(got string) error {
-				if !strings.Contains(got, "Some-Header") {
-					return errors.New("didn't get header")
-				}
-				return nil
-			},
-		},
-		{
-			name: "WriteHeader call",
-			handler: func(rw ResponseWriter, r *Request) {
-				rw.WriteHeader(404)
-				rw.Header().Set("Too-Late", "some-value")
-			},
-			check: func(got string) error {
-				if !strings.Contains(got, "404") {
-					return errors.New("wrong status")
-				}
-				if strings.Contains(got, "Some-Header") {
-					return errors.New("shouldn't have seen Too-Late")
-				}
-				return nil
-			},
-		},
-	}
-	for _, tc := range tests {
-		ht := newHandlerTest(HandlerFunc(tc.handler))
-		got := ht.rawResponse("GET / HTTP/1.1\nHost: golang.org")
-		if err := tc.check(got); err != nil {
-			t.Errorf("%s: %v\nGot response:\n%s", tc.name, err, got)
-		}
-	}
-}
-
-// goTimeout runs f, failing t if f takes more than ns to complete.
-func goTimeout(t *testing.T, d time.Duration, f func()) {
-	ch := make(chan bool, 2)
-	timer := time.AfterFunc(d, func() {
-		t.Errorf("Timeout expired after %v", d)
-		ch <- true
-	})
-	defer timer.Stop()
-	go func() {
-		defer func() { ch <- true }()
-		f()
-	}()
-	<-ch
-}
-
-type errorListener struct {
-	errs []error
-}
-
-func (l *errorListener) Accept() (c net.Conn, err error) {
-	if len(l.errs) == 0 {
-		return nil, io.EOF
-	}
-	err = l.errs[0]
-	l.errs = l.errs[1:]
-	return
-}
-
-func (l *errorListener) Close() error {
-	return nil
-}
-
-func (l *errorListener) Addr() net.Addr {
-	return dummyAddr("test-address")
-}
-
-func TestAcceptMaxFds(t *testing.T) {
-	log.SetOutput(ioutil.Discard) // is noisy otherwise
-	defer log.SetOutput(os.Stderr)
-
-	ln := &errorListener{[]error{
-		&net.OpError{
-			Op:  "accept",
-			Err: syscall.EMFILE,
-		}}}
-	err := Serve(ln, HandlerFunc(HandlerFunc(func(ResponseWriter, *Request) {})))
-	if err != io.EOF {
-		t.Errorf("got error %v, want EOF", err)
-	}
-}
-
-func TestWriteAfterHijack(t *testing.T) {
-	req := reqBytes("GET / HTTP/1.1\nHost: golang.org")
-	var buf bytes.Buffer
-	wrotec := make(chan bool, 1)
-	conn := &rwTestConn{
-		Reader: bytes.NewReader(req),
-		Writer: &buf,
-		closec: make(chan bool, 1),
-	}
-	handler := HandlerFunc(func(rw ResponseWriter, r *Request) {
-		conn, bufrw, err := rw.(Hijacker).Hijack()
-		if err != nil {
-			t.Error(err)
-			return
-		}
-		go func() {
-			bufrw.Write([]byte("[hijack-to-bufw]"))
-			bufrw.Flush()
-			conn.Write([]byte("[hijack-to-conn]"))
-			conn.Close()
-			wrotec <- true
-		}()
-	})
-	ln := &oneConnListener{conn: conn}
-	go Serve(ln, handler)
-	<-conn.closec
-	<-wrotec
-	if g, w := buf.String(), "[hijack-to-bufw][hijack-to-conn]"; g != w {
-		t.Errorf("wrote %q; want %q", g, w)
-	}
-}
-
-func TestDoubleHijack(t *testing.T) {
-	req := reqBytes("GET / HTTP/1.1\nHost: golang.org")
-	var buf bytes.Buffer
-	conn := &rwTestConn{
-		Reader: bytes.NewReader(req),
-		Writer: &buf,
-		closec: make(chan bool, 1),
-	}
-	handler := HandlerFunc(func(rw ResponseWriter, r *Request) {
-		conn, _, err := rw.(Hijacker).Hijack()
-		if err != nil {
-			t.Error(err)
-			return
-		}
-		_, _, err = rw.(Hijacker).Hijack()
-		if err == nil {
-			t.Errorf("got err = nil;  want err != nil")
-		}
-		conn.Close()
-	})
-	ln := &oneConnListener{conn: conn}
-	go Serve(ln, handler)
-	<-conn.closec
-}
-
-// http://code.google.com/p/go/issues/detail?id=5955
-// Note that this does not test the "request too large"
-// exit path from the http server. This is intentional;
-// not sending Connection: close is just a minor wire
-// optimization and is pointless if dealing with a
-// badly behaved client.
-func TestHTTP10ConnectionHeader(t *testing.T) {
-	defer afterTest(t)
-
-	mux := NewServeMux()
-	mux.Handle("/", HandlerFunc(func(resp ResponseWriter, req *Request) {}))
-	ts := httptest.NewServer(mux)
-	defer ts.Close()
-
-	// net/http uses HTTP/1.1 for requests, so write requests manually
-	tests := []struct {
-		req    string   // raw http request
-		expect []string // expected Connection header(s)
-	}{
-		{
-			req:    "GET / HTTP/1.0\r\n\r\n",
-			expect: nil,
-		},
-		{
-			req:    "OPTIONS * HTTP/1.0\r\n\r\n",
-			expect: nil,
-		},
-		{
-			req:    "GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n",
-			expect: []string{"keep-alive"},
-		},
-	}
-
-	for _, tt := range tests {
-		conn, err := net.Dial("tcp", ts.Listener.Addr().String())
-		if err != nil {
-			t.Fatal("dial err:", err)
-		}
-
-		_, err = fmt.Fprint(conn, tt.req)
-		if err != nil {
-			t.Fatal("conn write err:", err)
-		}
-
-		resp, err := ReadResponse(bufio.NewReader(conn), &Request{Method: "GET"})
-		if err != nil {
-			t.Fatal("ReadResponse err:", err)
-		}
-		conn.Close()
-		resp.Body.Close()
-
-		got := resp.Header["Connection"]
-		if !reflect.DeepEqual(got, tt.expect) {
-			t.Errorf("wrong Connection headers for request %q. Got %q expect %q", tt.req, got, tt.expect)
-		}
-	}
-}
-
-// See golang.org/issue/5660
-func TestServerReaderFromOrder(t *testing.T) {
-	defer afterTest(t)
-	pr, pw := io.Pipe()
-	const size = 3 << 20
-	ts := httptest.NewServer(HandlerFunc(func(rw ResponseWriter, req *Request) {
-		rw.Header().Set("Content-Type", "text/plain") // prevent sniffing path
-		done := make(chan bool)
-		go func() {
-			io.Copy(rw, pr)
-			close(done)
-		}()
-		time.Sleep(25 * time.Millisecond) // give Copy a chance to break things
-		n, err := io.Copy(ioutil.Discard, req.Body)
-		if err != nil {
-			t.Errorf("handler Copy: %v", err)
-			return
-		}
-		if n != size {
-			t.Errorf("handler Copy = %d; want %d", n, size)
-		}
-		pw.Write([]byte("hi"))
-		pw.Close()
-		<-done
-	}))
-	defer ts.Close()
-
-	req, err := NewRequest("POST", ts.URL, io.LimitReader(neverEnding('a'), size))
-	if err != nil {
-		t.Fatal(err)
-	}
-	res, err := DefaultClient.Do(req)
-	if err != nil {
-		t.Fatal(err)
-	}
-	all, err := ioutil.ReadAll(res.Body)
-	if err != nil {
-		t.Fatal(err)
-	}
-	res.Body.Close()
-	if string(all) != "hi" {
-		t.Errorf("Body = %q; want hi", all)
-	}
-}
-
-// Issue 6157, Issue 6685
-func TestCodesPreventingContentTypeAndBody(t *testing.T) {
-	for _, code := range []int{StatusNotModified, StatusNoContent, StatusContinue} {
-		ht := newHandlerTest(HandlerFunc(func(w ResponseWriter, r *Request) {
-			if r.URL.Path == "/header" {
-				w.Header().Set("Content-Length", "123")
-			}
-			w.WriteHeader(code)
-			if r.URL.Path == "/more" {
-				w.Write([]byte("stuff"))
-			}
-		}))
-		for _, req := range []string{
-			"GET / HTTP/1.0",
-			"GET /header HTTP/1.0",
-			"GET /more HTTP/1.0",
-			"GET / HTTP/1.1",
-			"GET /header HTTP/1.1",
-			"GET /more HTTP/1.1",
-		} {
-			got := ht.rawResponse(req)
-			wantStatus := fmt.Sprintf("%d %s", code, StatusText(code))
-			if !strings.Contains(got, wantStatus) {
-				t.Errorf("Code %d: Wanted %q Modified for %q: %s", code, wantStatus, req, got)
-			} else if strings.Contains(got, "Content-Length") {
-				t.Errorf("Code %d: Got a Content-Length from %q: %s", code, req, got)
-			} else if strings.Contains(got, "stuff") {
-				t.Errorf("Code %d: Response contains a body from %q: %s", code, req, got)
-			}
-		}
-	}
-}
-
-func TestContentTypeOkayOn204(t *testing.T) {
-	ht := newHandlerTest(HandlerFunc(func(w ResponseWriter, r *Request) {
-		w.Header().Set("Content-Length", "123") // suppressed
-		w.Header().Set("Content-Type", "foo/bar")
-		w.WriteHeader(204)
-	}))
-	got := ht.rawResponse("GET / HTTP/1.1")
-	if !strings.Contains(got, "Content-Type: foo/bar") {
-		t.Errorf("Response = %q; want Content-Type: foo/bar", got)
-	}
-	if strings.Contains(got, "Content-Length: 123") {
-		t.Errorf("Response = %q; don't want a Content-Length", got)
-	}
-}
-
-// Issue 6995
-// A server Handler can receive a Request, and then turn around and
-// give a copy of that Request.Body out to the Transport (e.g. any
-// proxy).  So then two people own that Request.Body (both the server
-// and the http client), and both think they can close it on failure.
-// Therefore, all incoming server requests Bodies need to be thread-safe.
-func TestTransportAndServerSharedBodyRace(t *testing.T) {
-	defer afterTest(t)
-
-	const bodySize = 1 << 20
-
-	unblockBackend := make(chan bool)
-	backend := httptest.NewServer(HandlerFunc(func(rw ResponseWriter, req *Request) {
-		io.CopyN(rw, req.Body, bodySize/2)
-		<-unblockBackend
-	}))
-	defer backend.Close()
-
-	backendRespc := make(chan *Response, 1)
-	proxy := httptest.NewServer(HandlerFunc(func(rw ResponseWriter, req *Request) {
-		if req.RequestURI == "/foo" {
-			rw.Write([]byte("bar"))
-			return
-		}
-		req2, _ := NewRequest("POST", backend.URL, req.Body)
-		req2.ContentLength = bodySize
-
-		bresp, err := DefaultClient.Do(req2)
-		if err != nil {
-			t.Errorf("Proxy outbound request: %v", err)
-			return
-		}
-		_, err = io.CopyN(ioutil.Discard, bresp.Body, bodySize/4)
-		if err != nil {
-			t.Errorf("Proxy copy error: %v", err)
-			return
-		}
-		backendRespc <- bresp // to close later
-
-		// Try to cause a race: Both the DefaultTransport and the proxy handler's Server
-		// will try to read/close req.Body (aka req2.Body)
-		DefaultTransport.(*Transport).CancelRequest(req2)
-		rw.Write([]byte("OK"))
-	}))
-	defer proxy.Close()
-
-	req, _ := NewRequest("POST", proxy.URL, io.LimitReader(neverEnding('a'), bodySize))
-	res, err := DefaultClient.Do(req)
-	if err != nil {
-		t.Fatalf("Original request: %v", err)
-	}
-
-	// Cleanup, so we don't leak goroutines.
-	res.Body.Close()
-	close(unblockBackend)
-	(<-backendRespc).Body.Close()
-}
-
-// Test that a hanging Request.Body.Read from another goroutine can't
-// cause the Handler goroutine's Request.Body.Close to block.
-func TestRequestBodyCloseDoesntBlock(t *testing.T) {
-	t.Skipf("Skipping known issue; see golang.org/issue/7121")
-	if testing.Short() {
-		t.Skip("skipping in -short mode")
-	}
-	defer afterTest(t)
-
-	readErrCh := make(chan error, 1)
-	errCh := make(chan error, 2)
-
-	server := httptest.NewServer(HandlerFunc(func(rw ResponseWriter, req *Request) {
-		go func(body io.Reader) {
-			_, err := body.Read(make([]byte, 100))
-			readErrCh <- err
-		}(req.Body)
-		time.Sleep(500 * time.Millisecond)
-	}))
-	defer server.Close()
-
-	closeConn := make(chan bool)
-	defer close(closeConn)
-	go func() {
-		conn, err := net.Dial("tcp", server.Listener.Addr().String())
-		if err != nil {
-			errCh <- err
-			return
-		}
-		defer conn.Close()
-		_, err = conn.Write([]byte("POST / HTTP/1.1\r\nConnection: close\r\nHost: foo\r\nContent-Length: 100000\r\n\r\n"))
-		if err != nil {
-			errCh <- err
-			return
-		}
-		// And now just block, making the server block on our
-		// 100000 bytes of body that will never arrive.
-		<-closeConn
-	}()
-	select {
-	case err := <-readErrCh:
-		if err == nil {
-			t.Error("Read was nil. Expected error.")
-		}
-	case err := <-errCh:
-		t.Error(err)
-	case <-time.After(5 * time.Second):
-		t.Error("timeout")
-	}
-}
-
-func TestResponseWriterWriteStringAllocs(t *testing.T) {
-	ht := newHandlerTest(HandlerFunc(func(w ResponseWriter, r *Request) {
-		if r.URL.Path == "/s" {
-			io.WriteString(w, "Hello world")
-		} else {
-			w.Write([]byte("Hello world"))
-		}
-	}))
-	before := testing.AllocsPerRun(50, func() { ht.rawResponse("GET / HTTP/1.0") })
-	after := testing.AllocsPerRun(50, func() { ht.rawResponse("GET /s HTTP/1.0") })
-	if int(after) >= int(before) {
-		t.Errorf("WriteString allocs of %v >= Write allocs of %v", after, before)
-	}
-}
-
-func TestAppendTime(t *testing.T) {
-	var b [len(TimeFormat)]byte
-	t1 := time.Date(2013, 9, 21, 15, 41, 0, 0, time.FixedZone("CEST", 2*60*60))
-	res := ExportAppendTime(b[:0], t1)
-	t2, err := ParseTime(string(res))
-	if err != nil {
-		t.Fatalf("Error parsing time: %s", err)
-	}
-	if !t1.Equal(t2) {
-		t.Fatalf("Times differ; expected: %v, got %v (%s)", t1, t2, string(res))
-	}
-}
-
-func TestServerConnState(t *testing.T) {
-	defer afterTest(t)
-	handler := map[string]func(w ResponseWriter, r *Request){
-		"/": func(w ResponseWriter, r *Request) {
-			fmt.Fprintf(w, "Hello.")
-		},
-		"/close": func(w ResponseWriter, r *Request) {
-			w.Header().Set("Connection", "close")
-			fmt.Fprintf(w, "Hello.")
-		},
-		"/hijack": func(w ResponseWriter, r *Request) {
-			c, _, _ := w.(Hijacker).Hijack()
-			c.Write([]byte("HTTP/1.0 200 OK\r\nConnection: close\r\n\r\nHello."))
-			c.Close()
-		},
-		"/hijack-panic": func(w ResponseWriter, r *Request) {
-			c, _, _ := w.(Hijacker).Hijack()
-			c.Write([]byte("HTTP/1.0 200 OK\r\nConnection: close\r\n\r\nHello."))
-			c.Close()
-			panic("intentional panic")
-		},
-	}
-	ts := httptest.NewUnstartedServer(HandlerFunc(func(w ResponseWriter, r *Request) {
-		handler[r.URL.Path](w, r)
-	}))
-	defer ts.Close()
-
-	var mu sync.Mutex // guard stateLog and connID
-	var stateLog = map[int][]ConnState{}
-	var connID = map[net.Conn]int{}
-
-	ts.Config.ErrorLog = log.New(ioutil.Discard, "", 0)
-	ts.Config.ConnState = func(c net.Conn, state ConnState) {
-		if c == nil {
-			t.Errorf("nil conn seen in state %s", state)
-			return
-		}
-		mu.Lock()
-		defer mu.Unlock()
-		id, ok := connID[c]
-		if !ok {
-			id = len(connID) + 1
-			connID[c] = id
-		}
-		stateLog[id] = append(stateLog[id], state)
-	}
-	ts.Start()
-
-	mustGet(t, ts.URL+"/")
-	mustGet(t, ts.URL+"/close")
-
-	mustGet(t, ts.URL+"/")
-	mustGet(t, ts.URL+"/", "Connection", "close")
-
-	mustGet(t, ts.URL+"/hijack")
-	mustGet(t, ts.URL+"/hijack-panic")
-
-	// New->Closed
-	{
-		c, err := net.Dial("tcp", ts.Listener.Addr().String())
-		if err != nil {
-			t.Fatal(err)
-		}
-		c.Close()
-	}
-
-	// New->Active->Closed
-	{
-		c, err := net.Dial("tcp", ts.Listener.Addr().String())
-		if err != nil {
-			t.Fatal(err)
-		}
-		if _, err := io.WriteString(c, "BOGUS REQUEST\r\n\r\n"); err != nil {
-			t.Fatal(err)
-		}
-		c.Close()
-	}
-
-	// New->Idle->Closed
-	{
-		c, err := net.Dial("tcp", ts.Listener.Addr().String())
-		if err != nil {
-			t.Fatal(err)
-		}
-		if _, err := io.WriteString(c, "GET / HTTP/1.1\r\nHost: foo\r\n\r\n"); err != nil {
-			t.Fatal(err)
-		}
-		res, err := ReadResponse(bufio.NewReader(c), nil)
-		if err != nil {
-			t.Fatal(err)
-		}
-		if _, err := io.Copy(ioutil.Discard, res.Body); err != nil {
-			t.Fatal(err)
-		}
-		c.Close()
-	}
-
-	want := map[int][]ConnState{
-		1: []ConnState{StateNew, StateActive, StateIdle, StateActive, StateClosed},
-		2: []ConnState{StateNew, StateActive, StateIdle, StateActive, StateClosed},
-		3: []ConnState{StateNew, StateActive, StateHijacked},
-		4: []ConnState{StateNew, StateActive, StateHijacked},
-		5: []ConnState{StateNew, StateClosed},
-		6: []ConnState{StateNew, StateActive, StateClosed},
-		7: []ConnState{StateNew, StateActive, StateIdle, StateClosed},
-	}
-	logString := func(m map[int][]ConnState) string {
-		var b bytes.Buffer
-		for id, l := range m {
-			fmt.Fprintf(&b, "Conn %d: ", id)
-			for _, s := range l {
-				fmt.Fprintf(&b, "%s ", s)
-			}
-			b.WriteString("\n")
-		}
-		return b.String()
-	}
-
-	for i := 0; i < 5; i++ {
-		time.Sleep(time.Duration(i) * 50 * time.Millisecond)
-		mu.Lock()
-		match := reflect.DeepEqual(stateLog, want)
-		mu.Unlock()
-		if match {
-			return
-		}
-	}
-
-	mu.Lock()
-	t.Errorf("Unexpected events.\nGot log: %s\n   Want: %s\n", logString(stateLog), logString(want))
-	mu.Unlock()
-}
-
-func mustGet(t *testing.T, url string, headers ...string) {
-	req, err := NewRequest("GET", url, nil)
-	if err != nil {
-		t.Fatal(err)
-	}
-	for len(headers) > 0 {
-		req.Header.Add(headers[0], headers[1])
-		headers = headers[2:]
-	}
-	res, err := DefaultClient.Do(req)
-	if err != nil {
-		t.Errorf("Error fetching %s: %v", url, err)
-		return
-	}
-	_, err = ioutil.ReadAll(res.Body)
-	defer res.Body.Close()
-	if err != nil {
-		t.Errorf("Error reading %s: %v", url, err)
-	}
-}
-
-func TestServerKeepAlivesEnabled(t *testing.T) {
-	defer afterTest(t)
-	ts := httptest.NewUnstartedServer(HandlerFunc(func(w ResponseWriter, r *Request) {}))
-	ts.Config.SetKeepAlivesEnabled(false)
-	ts.Start()
-	defer ts.Close()
-	res, err := Get(ts.URL)
-	if err != nil {
-		t.Fatal(err)
-	}
-	defer res.Body.Close()
-	if !res.Close {
-		t.Errorf("Body.Close == false; want true")
-	}
-}
-
-// golang.org/issue/7856
-func TestServerEmptyBodyRace(t *testing.T) {
-	defer afterTest(t)
-	var n int32
-	ts := httptest.NewServer(HandlerFunc(func(rw ResponseWriter, req *Request) {
-		atomic.AddInt32(&n, 1)
-	}))
-	defer ts.Close()
-	var wg sync.WaitGroup
-	const reqs = 20
-	for i := 0; i < reqs; i++ {
-		wg.Add(1)
-		go func() {
-			defer wg.Done()
-			res, err := Get(ts.URL)
-			if err != nil {
-				t.Error(err)
-				return
-			}
-			defer res.Body.Close()
-			_, err = io.Copy(ioutil.Discard, res.Body)
-			if err != nil {
-				t.Error(err)
-				return
-			}
-		}()
-	}
-	wg.Wait()
-	if got := atomic.LoadInt32(&n); got != reqs {
-		t.Errorf("handler ran %d times; want %d", got, reqs)
-	}
-}
-
-func TestServerConnStateNew(t *testing.T) {
-	sawNew := false // if the test is buggy, we'll race on this variable.
-	srv := &Server{
-		ConnState: func(c net.Conn, state ConnState) {
-			if state == StateNew {
-				sawNew = true // testing that this write isn't racy
-			}
-		},
-		Handler: HandlerFunc(func(w ResponseWriter, r *Request) {}), // irrelevant
-	}
-	srv.Serve(&oneConnListener{
-		conn: &rwTestConn{
-			Reader: strings.NewReader("GET / HTTP/1.1\r\nHost: foo\r\n\r\n"),
-			Writer: ioutil.Discard,
-		},
-	})
-	if !sawNew { // testing that this read isn't racy
-		t.Error("StateNew not seen")
-	}
-}
-
-func BenchmarkClientServer(b *testing.B) {
-	b.ReportAllocs()
-	b.StopTimer()
-	ts := httptest.NewServer(HandlerFunc(func(rw ResponseWriter, r *Request) {
-		fmt.Fprintf(rw, "Hello world.\n")
-	}))
-	defer ts.Close()
-	b.StartTimer()
-
-	for i := 0; i < b.N; i++ {
-		res, err := Get(ts.URL)
-		if err != nil {
-			b.Fatal("Get:", err)
-		}
-		all, err := ioutil.ReadAll(res.Body)
-		res.Body.Close()
-		if err != nil {
-			b.Fatal("ReadAll:", err)
-		}
-		body := string(all)
-		if body != "Hello world.\n" {
-			b.Fatal("Got body:", body)
-		}
-	}
-
-	b.StopTimer()
-}
-
-// A benchmark for profiling the server without the HTTP client code.
-// The client code runs in a subprocess.
-//
-// For use like:
-//   $ go test -c
-//   $ ./http.test -test.run=XX -test.bench=BenchmarkServer -test.benchtime=15s -test.cpuprofile=http.prof
-//   $ go tool pprof http.test http.prof
-//   (pprof) web
-func BenchmarkServer(b *testing.B) {
-	b.ReportAllocs()
-	// Child process mode;
-	if url := os.Getenv("TEST_BENCH_SERVER_URL"); url != "" {
-		n, err := strconv.Atoi(os.Getenv("TEST_BENCH_CLIENT_N"))
-		if err != nil {
-			panic(err)
-		}
-		for i := 0; i < n; i++ {
-			res, err := Get(url)
-			if err != nil {
-				log.Panicf("Get: %v", err)
-			}
-			all, err := ioutil.ReadAll(res.Body)
-			res.Body.Close()
-			if err != nil {
-				log.Panicf("ReadAll: %v", err)
-			}
-			body := string(all)
-			if body != "Hello world.\n" {
-				log.Panicf("Got body: %q", body)
-			}
-		}
-		os.Exit(0)
-		return
-	}
-
-	var res = []byte("Hello world.\n")
-	b.StopTimer()
-	ts := httptest.NewServer(HandlerFunc(func(rw ResponseWriter, r *Request) {
-		rw.Header().Set("Content-Type", "text/html; charset=utf-8")
-		rw.Write(res)
-	}))
-	defer ts.Close()
-	b.StartTimer()
-
-	cmd := exec.Command(os.Args[0], "-test.run=XXXX", "-test.bench=BenchmarkServer")
-	cmd.Env = append([]string{
-		fmt.Sprintf("TEST_BENCH_CLIENT_N=%d", b.N),
-		fmt.Sprintf("TEST_BENCH_SERVER_URL=%s", ts.URL),
-	}, os.Environ()...)
-	out, err := cmd.CombinedOutput()
-	if err != nil {
-		b.Errorf("Test failure: %v, with output: %s", err, out)
-	}
-}
-
-func BenchmarkServerFakeConnNoKeepAlive(b *testing.B) {
-	b.ReportAllocs()
-	req := reqBytes(`GET / HTTP/1.0
-Host: golang.org
-Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
-User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/537.17 (KHTML, like Gecko) Chrome/24.0.1312.52 Safari/537.17
-Accept-Encoding: gzip,deflate,sdch
-Accept-Language: en-US,en;q=0.8
-Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3
-`)
-	res := []byte("Hello world!\n")
-
-	conn := &testConn{
-		// testConn.Close will not push into the channel
-		// if it's full.
-		closec: make(chan bool, 1),
-	}
-	handler := HandlerFunc(func(rw ResponseWriter, r *Request) {
-		rw.Header().Set("Content-Type", "text/html; charset=utf-8")
-		rw.Write(res)
-	})
-	ln := new(oneConnListener)
-	for i := 0; i < b.N; i++ {
-		conn.readBuf.Reset()
-		conn.writeBuf.Reset()
-		conn.readBuf.Write(req)
-		ln.conn = conn
-		Serve(ln, handler)
-		<-conn.closec
-	}
-}
-
-// repeatReader reads content count times, then EOFs.
-type repeatReader struct {
-	content []byte
-	count   int
-	off     int
-}
-
-func (r *repeatReader) Read(p []byte) (n int, err error) {
-	if r.count <= 0 {
-		return 0, io.EOF
-	}
-	n = copy(p, r.content[r.off:])
-	r.off += n
-	if r.off == len(r.content) {
-		r.count--
-		r.off = 0
-	}
-	return
-}
-
-func BenchmarkServerFakeConnWithKeepAlive(b *testing.B) {
-	b.ReportAllocs()
-
-	req := reqBytes(`GET / HTTP/1.1
-Host: golang.org
-Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
-User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/537.17 (KHTML, like Gecko) Chrome/24.0.1312.52 Safari/537.17
-Accept-Encoding: gzip,deflate,sdch
-Accept-Language: en-US,en;q=0.8
-Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3
-`)
-	res := []byte("Hello world!\n")
-
-	conn := &rwTestConn{
-		Reader: &repeatReader{content: req, count: b.N},
-		Writer: ioutil.Discard,
-		closec: make(chan bool, 1),
-	}
-	handled := 0
-	handler := HandlerFunc(func(rw ResponseWriter, r *Request) {
-		handled++
-		rw.Header().Set("Content-Type", "text/html; charset=utf-8")
-		rw.Write(res)
-	})
-	ln := &oneConnListener{conn: conn}
-	go Serve(ln, handler)
-	<-conn.closec
-	if b.N != handled {
-		b.Errorf("b.N=%d but handled %d", b.N, handled)
-	}
-}
-
-// same as above, but representing the most simple possible request
-// and handler. Notably: the handler does not call rw.Header().
-func BenchmarkServerFakeConnWithKeepAliveLite(b *testing.B) {
-	b.ReportAllocs()
-
-	req := reqBytes(`GET / HTTP/1.1
-Host: golang.org
-`)
-	res := []byte("Hello world!\n")
-
-	conn := &rwTestConn{
-		Reader: &repeatReader{content: req, count: b.N},
-		Writer: ioutil.Discard,
-		closec: make(chan bool, 1),
-	}
-	handled := 0
-	handler := HandlerFunc(func(rw ResponseWriter, r *Request) {
-		handled++
-		rw.Write(res)
-	})
-	ln := &oneConnListener{conn: conn}
-	go Serve(ln, handler)
-	<-conn.closec
-	if b.N != handled {
-		b.Errorf("b.N=%d but handled %d", b.N, handled)
-	}
-}
-
-const someResponse = "<html>some response</html>"
-
-// A Response that's just no bigger than 2KB, the buffer-before-chunking threshold.
-var response = bytes.Repeat([]byte(someResponse), 2<<10/len(someResponse))
-
-// Both Content-Type and Content-Length set. Should be no buffering.
-func BenchmarkServerHandlerTypeLen(b *testing.B) {
-	benchmarkHandler(b, HandlerFunc(func(w ResponseWriter, r *Request) {
-		w.Header().Set("Content-Type", "text/html")
-		w.Header().Set("Content-Length", strconv.Itoa(len(response)))
-		w.Write(response)
-	}))
-}
-
-// A Content-Type is set, but no length. No sniffing, but will count the Content-Length.
-func BenchmarkServerHandlerNoLen(b *testing.B) {
-	benchmarkHandler(b, HandlerFunc(func(w ResponseWriter, r *Request) {
-		w.Header().Set("Content-Type", "text/html")
-		w.Write(response)
-	}))
-}
-
-// A Content-Length is set, but the Content-Type will be sniffed.
-func BenchmarkServerHandlerNoType(b *testing.B) {
-	benchmarkHandler(b, HandlerFunc(func(w ResponseWriter, r *Request) {
-		w.Header().Set("Content-Length", strconv.Itoa(len(response)))
-		w.Write(response)
-	}))
-}
-
-// Neither a Content-Type or Content-Length, so sniffed and counted.
-func BenchmarkServerHandlerNoHeader(b *testing.B) {
-	benchmarkHandler(b, HandlerFunc(func(w ResponseWriter, r *Request) {
-		w.Write(response)
-	}))
-}
-
-func benchmarkHandler(b *testing.B, h Handler) {
-	b.ReportAllocs()
-	req := reqBytes(`GET / HTTP/1.1
-Host: golang.org
-`)
-	conn := &rwTestConn{
-		Reader: &repeatReader{content: req, count: b.N},
-		Writer: ioutil.Discard,
-		closec: make(chan bool, 1),
-	}
-	handled := 0
-	handler := HandlerFunc(func(rw ResponseWriter, r *Request) {
-		handled++
-		h.ServeHTTP(rw, r)
-	})
-	ln := &oneConnListener{conn: conn}
-	go Serve(ln, handler)
-	<-conn.closec
-	if b.N != handled {
-		b.Errorf("b.N=%d but handled %d", b.N, handled)
-	}
-}
-
-func BenchmarkServerHijack(b *testing.B) {
-	b.ReportAllocs()
-	req := reqBytes(`GET / HTTP/1.1
-Host: golang.org
-`)
-	h := HandlerFunc(func(w ResponseWriter, r *Request) {
-		conn, _, err := w.(Hijacker).Hijack()
-		if err != nil {
-			panic(err)
-		}
-		conn.Close()
-	})
-	conn := &rwTestConn{
-		Writer: ioutil.Discard,
-		closec: make(chan bool, 1),
-	}
-	ln := &oneConnListener{conn: conn}
-	for i := 0; i < b.N; i++ {
-		conn.Reader = bytes.NewReader(req)
-		ln.conn = conn
-		Serve(ln, h)
-		<-conn.closec
-	}
-}

=== modified file 'http13client/server.go'
--- http13client/server.go	2014-06-20 11:00:47 +0000
+++ http13client/server.go	2014-06-20 12:05:53 +0000
@@ -2,1976 +2,16 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// HTTP server.  See RFC 2616.
-
 package http
 
 import (
-	"bufio"
-	"crypto/tls"
-	"errors"
 	"fmt"
 	"io"
 	"io/ioutil"
 	"log"
 	"net"
-	"net/url"
-	"os"
-	"path"
-	"runtime"
-	"strconv"
-	"strings"
 	"sync"
-	"sync/atomic"
-	"time"
-)
-
-// Errors introduced by the HTTP server.
-var (
-	ErrWriteAfterFlush = errors.New("Conn.Write called after Flush")
-	ErrBodyNotAllowed  = errors.New("http: request method or response status code does not allow body")
-	ErrHijacked        = errors.New("Conn has been hijacked")
-	ErrContentLength   = errors.New("Conn.Write wrote more than the declared Content-Length")
-)
-
-// Objects implementing the Handler interface can be
-// registered to serve a particular path or subtree
-// in the HTTP server.
-//
-// ServeHTTP should write reply headers and data to the ResponseWriter
-// and then return.  Returning signals that the request is finished
-// and that the HTTP server can move on to the next request on
-// the connection.
-type Handler interface {
-	ServeHTTP(ResponseWriter, *Request)
-}
-
-// A ResponseWriter interface is used by an HTTP handler to
-// construct an HTTP response.
-type ResponseWriter interface {
-	// Header returns the header map that will be sent by WriteHeader.
-	// Changing the header after a call to WriteHeader (or Write) has
-	// no effect.
-	Header() Header
-
-	// Write writes the data to the connection as part of an HTTP reply.
-	// If WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK)
-	// before writing the data.  If the Header does not contain a
-	// Content-Type line, Write adds a Content-Type set to the result of passing
-	// the initial 512 bytes of written data to DetectContentType.
-	Write([]byte) (int, error)
-
-	// WriteHeader sends an HTTP response header with status code.
-	// If WriteHeader is not called explicitly, the first call to Write
-	// will trigger an implicit WriteHeader(http.StatusOK).
-	// Thus explicit calls to WriteHeader are mainly used to
-	// send error codes.
-	WriteHeader(int)
-}
-
-// The Flusher interface is implemented by ResponseWriters that allow
-// an HTTP handler to flush buffered data to the client.
-//
-// Note that even for ResponseWriters that support Flush,
-// if the client is connected through an HTTP proxy,
-// the buffered data may not reach the client until the response
-// completes.
-type Flusher interface {
-	// Flush sends any buffered data to the client.
-	Flush()
-}
-
-// The Hijacker interface is implemented by ResponseWriters that allow
-// an HTTP handler to take over the connection.
-type Hijacker interface {
-	// Hijack lets the caller take over the connection.
-	// After a call to Hijack(), the HTTP server library
-	// will not do anything else with the connection.
-	// It becomes the caller's responsibility to manage
-	// and close the connection.
-	Hijack() (net.Conn, *bufio.ReadWriter, error)
-}
-
-// The CloseNotifier interface is implemented by ResponseWriters which
-// allow detecting when the underlying connection has gone away.
-//
-// This mechanism can be used to cancel long operations on the server
-// if the client has disconnected before the response is ready.
-type CloseNotifier interface {
-	// CloseNotify returns a channel that receives a single value
-	// when the client connection has gone away.
-	CloseNotify() <-chan bool
-}
-
-// A conn represents the server side of an HTTP connection.
-type conn struct {
-	remoteAddr string               // network address of remote side
-	server     *Server              // the Server on which the connection arrived
-	rwc        net.Conn             // i/o connection
-	sr         liveSwitchReader     // where the LimitReader reads from; usually the rwc
-	lr         *io.LimitedReader    // io.LimitReader(sr)
-	buf        *bufio.ReadWriter    // buffered(lr,rwc), reading from bufio->limitReader->sr->rwc
-	tlsState   *tls.ConnectionState // or nil when not using TLS
-
-	mu           sync.Mutex // guards the following
-	clientGone   bool       // if client has disconnected mid-request
-	closeNotifyc chan bool  // made lazily
-	hijackedv    bool       // connection has been hijacked by handler
-}
-
-func (c *conn) hijacked() bool {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-	return c.hijackedv
-}
-
-func (c *conn) hijack() (rwc net.Conn, buf *bufio.ReadWriter, err error) {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-	if c.hijackedv {
-		return nil, nil, ErrHijacked
-	}
-	if c.closeNotifyc != nil {
-		return nil, nil, errors.New("http: Hijack is incompatible with use of CloseNotifier")
-	}
-	c.hijackedv = true
-	rwc = c.rwc
-	buf = c.buf
-	c.rwc = nil
-	c.buf = nil
-	c.setState(rwc, StateHijacked)
-	return
-}
-
-func (c *conn) closeNotify() <-chan bool {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-	if c.closeNotifyc == nil {
-		c.closeNotifyc = make(chan bool, 1)
-		if c.hijackedv {
-			// to obey the function signature, even though
-			// it'll never receive a value.
-			return c.closeNotifyc
-		}
-		pr, pw := io.Pipe()
-
-		readSource := c.sr.r
-		c.sr.Lock()
-		c.sr.r = pr
-		c.sr.Unlock()
-		go func() {
-			_, err := io.Copy(pw, readSource)
-			if err == nil {
-				err = io.EOF
-			}
-			pw.CloseWithError(err)
-			c.noteClientGone()
-		}()
-	}
-	return c.closeNotifyc
-}
-
-func (c *conn) noteClientGone() {
-	c.mu.Lock()
-	defer c.mu.Unlock()
-	if c.closeNotifyc != nil && !c.clientGone {
-		c.closeNotifyc <- true
-	}
-	c.clientGone = true
-}
-
-// A switchReader can have its Reader changed at runtime.
-// It's not safe for concurrent Reads and switches.
-type switchReader struct {
-	io.Reader
-}
-
-// A switchWriter can have its Writer changed at runtime.
-// It's not safe for concurrent Writes and switches.
-type switchWriter struct {
-	io.Writer
-}
-
-// A liveSwitchReader is a switchReader that's safe for concurrent
-// reads and switches, if its mutex is held.
-type liveSwitchReader struct {
-	sync.Mutex
-	r io.Reader
-}
-
-func (sr *liveSwitchReader) Read(p []byte) (n int, err error) {
-	sr.Lock()
-	r := sr.r
-	sr.Unlock()
-	return r.Read(p)
-}
-
-// This should be >= 512 bytes for DetectContentType,
-// but otherwise it's somewhat arbitrary.
-const bufferBeforeChunkingSize = 2048
-
-// chunkWriter writes to a response's conn buffer, and is the writer
-// wrapped by the response.bufw buffered writer.
-//
-// chunkWriter also is responsible for finalizing the Header, including
-// conditionally setting the Content-Type and setting a Content-Length
-// in cases where the handler's final output is smaller than the buffer
-// size. It also conditionally adds chunk headers, when in chunking mode.
-//
-// See the comment above (*response).Write for the entire write flow.
-type chunkWriter struct {
-	res *response
-
-	// header is either nil or a deep clone of res.handlerHeader
-	// at the time of res.WriteHeader, if res.WriteHeader is
-	// called and extra buffering is being done to calculate
-	// Content-Type and/or Content-Length.
-	header Header
-
-	// wroteHeader tells whether the header's been written to "the
-	// wire" (or rather: w.conn.buf). this is unlike
-	// (*response).wroteHeader, which tells only whether it was
-	// logically written.
-	wroteHeader bool
-
-	// set by the writeHeader method:
-	chunking bool // using chunked transfer encoding for reply body
-}
-
-var (
-	crlf       = []byte("\r\n")
-	colonSpace = []byte(": ")
-)
-
-func (cw *chunkWriter) Write(p []byte) (n int, err error) {
-	if !cw.wroteHeader {
-		cw.writeHeader(p)
-	}
-	if cw.res.req.Method == "HEAD" {
-		// Eat writes.
-		return len(p), nil
-	}
-	if cw.chunking {
-		_, err = fmt.Fprintf(cw.res.conn.buf, "%x\r\n", len(p))
-		if err != nil {
-			cw.res.conn.rwc.Close()
-			return
-		}
-	}
-	n, err = cw.res.conn.buf.Write(p)
-	if cw.chunking && err == nil {
-		_, err = cw.res.conn.buf.Write(crlf)
-	}
-	if err != nil {
-		cw.res.conn.rwc.Close()
-	}
-	return
-}
-
-func (cw *chunkWriter) flush() {
-	if !cw.wroteHeader {
-		cw.writeHeader(nil)
-	}
-	cw.res.conn.buf.Flush()
-}
-
-func (cw *chunkWriter) close() {
-	if !cw.wroteHeader {
-		cw.writeHeader(nil)
-	}
-	if cw.chunking {
-		// zero EOF chunk, trailer key/value pairs (currently
-		// unsupported in Go's server), followed by a blank
-		// line.
-		cw.res.conn.buf.WriteString("0\r\n\r\n")
-	}
-}
-
-// A response represents the server side of an HTTP response.
-type response struct {
-	conn          *conn
-	req           *Request // request for this response
-	wroteHeader   bool     // reply header has been (logically) written
-	wroteContinue bool     // 100 Continue response was written
-
-	w  *bufio.Writer // buffers output in chunks to chunkWriter
-	cw chunkWriter
-	sw *switchWriter // of the bufio.Writer, for return to putBufioWriter
-
-	// handlerHeader is the Header that Handlers get access to,
-	// which may be retained and mutated even after WriteHeader.
-	// handlerHeader is copied into cw.header at WriteHeader
-	// time, and privately mutated thereafter.
-	handlerHeader Header
-	calledHeader  bool // handler accessed handlerHeader via Header
-
-	written       int64 // number of bytes written in body
-	contentLength int64 // explicitly-declared Content-Length; or -1
-	status        int   // status code passed to WriteHeader
-
-	// close connection after this reply.  set on request and
-	// updated after response from handler if there's a
-	// "Connection: keep-alive" response header and a
-	// Content-Length.
-	closeAfterReply bool
-
-	// requestBodyLimitHit is set by requestTooLarge when
-	// maxBytesReader hits its max size. It is checked in
-	// WriteHeader, to make sure we don't consume the
-	// remaining request body to try to advance to the next HTTP
-	// request. Instead, when this is set, we stop reading
-	// subsequent requests on this connection and stop reading
-	// input from it.
-	requestBodyLimitHit bool
-
-	handlerDone bool // set true when the handler exits
-
-	// Buffers for Date and Content-Length
-	dateBuf [len(TimeFormat)]byte
-	clenBuf [10]byte
-}
-
-// requestTooLarge is called by maxBytesReader when too much input has
-// been read from the client.
-func (w *response) requestTooLarge() {
-	w.closeAfterReply = true
-	w.requestBodyLimitHit = true
-	if !w.wroteHeader {
-		w.Header().Set("Connection", "close")
-	}
-}
-
-// needsSniff reports whether a Content-Type still needs to be sniffed.
-func (w *response) needsSniff() bool {
-	_, haveType := w.handlerHeader["Content-Type"]
-	return !w.cw.wroteHeader && !haveType && w.written < sniffLen
-}
-
-// writerOnly hides an io.Writer value's optional ReadFrom method
-// from io.Copy.
-type writerOnly struct {
-	io.Writer
-}
-
-func srcIsRegularFile(src io.Reader) (isRegular bool, err error) {
-	switch v := src.(type) {
-	case *os.File:
-		fi, err := v.Stat()
-		if err != nil {
-			return false, err
-		}
-		return fi.Mode().IsRegular(), nil
-	case *io.LimitedReader:
-		return srcIsRegularFile(v.R)
-	default:
-		return
-	}
-}
-
-// ReadFrom is here to optimize copying from an *os.File regular file
-// to a *net.TCPConn with sendfile.
-func (w *response) ReadFrom(src io.Reader) (n int64, err error) {
-	// Our underlying w.conn.rwc is usually a *TCPConn (with its
-	// own ReadFrom method). If not, or if our src isn't a regular
-	// file, just fall back to the normal copy method.
-	rf, ok := w.conn.rwc.(io.ReaderFrom)
-	regFile, err := srcIsRegularFile(src)
-	if err != nil {
-		return 0, err
-	}
-	if !ok || !regFile {
-		return io.Copy(writerOnly{w}, src)
-	}
-
-	// sendfile path:
-
-	if !w.wroteHeader {
-		w.WriteHeader(StatusOK)
-	}
-
-	if w.needsSniff() {
-		n0, err := io.Copy(writerOnly{w}, io.LimitReader(src, sniffLen))
-		n += n0
-		if err != nil {
-			return n, err
-		}
-	}
-
-	w.w.Flush()  // get rid of any previous writes
-	w.cw.flush() // make sure Header is written; flush data to rwc
-
-	// Now that cw has been flushed, its chunking field is guaranteed initialized.
-	if !w.cw.chunking && w.bodyAllowed() {
-		n0, err := rf.ReadFrom(src)
-		n += n0
-		w.written += n0
-		return n, err
-	}
-
-	n0, err := io.Copy(writerOnly{w}, src)
-	n += n0
-	return n, err
-}
-
-// noLimit is an effective infinite upper bound for io.LimitedReader
-const noLimit int64 = (1 << 63) - 1
-
-// debugServerConnections controls whether all server connections are wrapped
-// with a verbose logging wrapper.
-const debugServerConnections = false
-
-// Create new connection from rwc.
-func (srv *Server) newConn(rwc net.Conn) (c *conn, err error) {
-	c = new(conn)
-	c.remoteAddr = rwc.RemoteAddr().String()
-	c.server = srv
-	c.rwc = rwc
-	if debugServerConnections {
-		c.rwc = newLoggingConn("server", c.rwc)
-	}
-	c.sr = liveSwitchReader{r: c.rwc}
-	c.lr = io.LimitReader(&c.sr, noLimit).(*io.LimitedReader)
-	br := newBufioReader(c.lr)
-	bw := newBufioWriterSize(c.rwc, 4<<10)
-	c.buf = bufio.NewReadWriter(br, bw)
-	return c, nil
-}
-
-// TODO: use a sync.Cache instead
-var (
-	bufioReaderCache   = make(chan *bufio.Reader, 4)
-	bufioWriterCache2k = make(chan *bufio.Writer, 4)
-	bufioWriterCache4k = make(chan *bufio.Writer, 4)
-)
-
-func bufioWriterCache(size int) chan *bufio.Writer {
-	switch size {
-	case 2 << 10:
-		return bufioWriterCache2k
-	case 4 << 10:
-		return bufioWriterCache4k
-	}
-	return nil
-}
-
-func newBufioReader(r io.Reader) *bufio.Reader {
-	select {
-	case p := <-bufioReaderCache:
-		p.Reset(r)
-		return p
-	default:
-		return bufio.NewReader(r)
-	}
-}
-
-func putBufioReader(br *bufio.Reader) {
-	br.Reset(nil)
-	select {
-	case bufioReaderCache <- br:
-	default:
-	}
-}
-
-func newBufioWriterSize(w io.Writer, size int) *bufio.Writer {
-	select {
-	case p := <-bufioWriterCache(size):
-		p.Reset(w)
-		return p
-	default:
-		return bufio.NewWriterSize(w, size)
-	}
-}
-
-func putBufioWriter(bw *bufio.Writer) {
-	bw.Reset(nil)
-	select {
-	case bufioWriterCache(bw.Available()) <- bw:
-	default:
-	}
-}
-
-// DefaultMaxHeaderBytes is the maximum permitted size of the headers
-// in an HTTP request.
-// This can be overridden by setting Server.MaxHeaderBytes.
-const DefaultMaxHeaderBytes = 1 << 20 // 1 MB
-
-func (srv *Server) maxHeaderBytes() int {
-	if srv.MaxHeaderBytes > 0 {
-		return srv.MaxHeaderBytes
-	}
-	return DefaultMaxHeaderBytes
-}
-
-func (srv *Server) initialLimitedReaderSize() int64 {
-	return int64(srv.maxHeaderBytes()) + 4096 // bufio slop
-}
-
-// wrapper around io.ReaderCloser which on first read, sends an
-// HTTP/1.1 100 Continue header
-type expectContinueReader struct {
-	resp       *response
-	readCloser io.ReadCloser
-	closed     bool
-}
-
-func (ecr *expectContinueReader) Read(p []byte) (n int, err error) {
-	if ecr.closed {
-		return 0, ErrBodyReadAfterClose
-	}
-	if !ecr.resp.wroteContinue && !ecr.resp.conn.hijacked() {
-		ecr.resp.wroteContinue = true
-		ecr.resp.conn.buf.WriteString("HTTP/1.1 100 Continue\r\n\r\n")
-		ecr.resp.conn.buf.Flush()
-	}
-	return ecr.readCloser.Read(p)
-}
-
-func (ecr *expectContinueReader) Close() error {
-	ecr.closed = true
-	return ecr.readCloser.Close()
-}
-
-// TimeFormat is the time format to use with
-// time.Parse and time.Time.Format when parsing
-// or generating times in HTTP headers.
-// It is like time.RFC1123 but hard codes GMT as the time zone.
-const TimeFormat = "Mon, 02 Jan 2006 15:04:05 GMT"
-
-// appendTime is a non-allocating version of []byte(t.UTC().Format(TimeFormat))
-func appendTime(b []byte, t time.Time) []byte {
-	const days = "SunMonTueWedThuFriSat"
-	const months = "JanFebMarAprMayJunJulAugSepOctNovDec"
-
-	t = t.UTC()
-	yy, mm, dd := t.Date()
-	hh, mn, ss := t.Clock()
-	day := days[3*t.Weekday():]
-	mon := months[3*(mm-1):]
-
-	return append(b,
-		day[0], day[1], day[2], ',', ' ',
-		byte('0'+dd/10), byte('0'+dd%10), ' ',
-		mon[0], mon[1], mon[2], ' ',
-		byte('0'+yy/1000), byte('0'+(yy/100)%10), byte('0'+(yy/10)%10), byte('0'+yy%10), ' ',
-		byte('0'+hh/10), byte('0'+hh%10), ':',
-		byte('0'+mn/10), byte('0'+mn%10), ':',
-		byte('0'+ss/10), byte('0'+ss%10), ' ',
-		'G', 'M', 'T')
-}
-
-var errTooLarge = errors.New("http: request too large")
-
-// Read next request from connection.
-func (c *conn) readRequest() (w *response, err error) {
-	if c.hijacked() {
-		return nil, ErrHijacked
-	}
-
-	if d := c.server.ReadTimeout; d != 0 {
-		c.rwc.SetReadDeadline(time.Now().Add(d))
-	}
-	if d := c.server.WriteTimeout; d != 0 {
-		defer func() {
-			c.rwc.SetWriteDeadline(time.Now().Add(d))
-		}()
-	}
-
-	c.lr.N = c.server.initialLimitedReaderSize()
-	var req *Request
-	if req, err = ReadRequest(c.buf.Reader); err != nil {
-		if c.lr.N == 0 {
-			return nil, errTooLarge
-		}
-		return nil, err
-	}
-	c.lr.N = noLimit
-
-	req.RemoteAddr = c.remoteAddr
-	req.TLS = c.tlsState
-
-	w = &response{
-		conn:          c,
-		req:           req,
-		handlerHeader: make(Header),
-		contentLength: -1,
-	}
-	w.cw.res = w
-	w.w = newBufioWriterSize(&w.cw, bufferBeforeChunkingSize)
-	return w, nil
-}
-
-func (w *response) Header() Header {
-	if w.cw.header == nil && w.wroteHeader && !w.cw.wroteHeader {
-		// Accessing the header between logically writing it
-		// and physically writing it means we need to allocate
-		// a clone to snapshot the logically written state.
-		w.cw.header = w.handlerHeader.clone()
-	}
-	w.calledHeader = true
-	return w.handlerHeader
-}
-
-// maxPostHandlerReadBytes is the max number of Request.Body bytes not
-// consumed by a handler that the server will read from the client
-// in order to keep a connection alive.  If there are more bytes than
-// this then the server to be paranoid instead sends a "Connection:
-// close" response.
-//
-// This number is approximately what a typical machine's TCP buffer
-// size is anyway.  (if we have the bytes on the machine, we might as
-// well read them)
-const maxPostHandlerReadBytes = 256 << 10
-
-func (w *response) WriteHeader(code int) {
-	if w.conn.hijacked() {
-		w.conn.server.logf("http: response.WriteHeader on hijacked connection")
-		return
-	}
-	if w.wroteHeader {
-		w.conn.server.logf("http: multiple response.WriteHeader calls")
-		return
-	}
-	w.wroteHeader = true
-	w.status = code
-
-	if w.calledHeader && w.cw.header == nil {
-		w.cw.header = w.handlerHeader.clone()
-	}
-
-	if cl := w.handlerHeader.get("Content-Length"); cl != "" {
-		v, err := strconv.ParseInt(cl, 10, 64)
-		if err == nil && v >= 0 {
-			w.contentLength = v
-		} else {
-			w.conn.server.logf("http: invalid Content-Length of %q", cl)
-			w.handlerHeader.Del("Content-Length")
-		}
-	}
-}
-
-// extraHeader is the set of headers sometimes added by chunkWriter.writeHeader.
-// This type is used to avoid extra allocations from cloning and/or populating
-// the response Header map and all its 1-element slices.
-type extraHeader struct {
-	contentType      string
-	connection       string
-	transferEncoding string
-	date             []byte // written if not nil
-	contentLength    []byte // written if not nil
-}
-
-// Sorted the same as extraHeader.Write's loop.
-var extraHeaderKeys = [][]byte{
-	[]byte("Content-Type"),
-	[]byte("Connection"),
-	[]byte("Transfer-Encoding"),
-}
-
-var (
-	headerContentLength = []byte("Content-Length: ")
-	headerDate          = []byte("Date: ")
-)
-
-// Write writes the headers described in h to w.
-//
-// This method has a value receiver, despite the somewhat large size
-// of h, because it prevents an allocation. The escape analysis isn't
-// smart enough to realize this function doesn't mutate h.
-func (h extraHeader) Write(w *bufio.Writer) {
-	if h.date != nil {
-		w.Write(headerDate)
-		w.Write(h.date)
-		w.Write(crlf)
-	}
-	if h.contentLength != nil {
-		w.Write(headerContentLength)
-		w.Write(h.contentLength)
-		w.Write(crlf)
-	}
-	for i, v := range []string{h.contentType, h.connection, h.transferEncoding} {
-		if v != "" {
-			w.Write(extraHeaderKeys[i])
-			w.Write(colonSpace)
-			w.WriteString(v)
-			w.Write(crlf)
-		}
-	}
-}
-
-// writeHeader finalizes the header sent to the client and writes it
-// to cw.res.conn.buf.
-//
-// p is not written by writeHeader, but is the first chunk of the body
-// that will be written.  It is sniffed for a Content-Type if none is
-// set explicitly.  It's also used to set the Content-Length, if the
-// total body size was small and the handler has already finished
-// running.
-func (cw *chunkWriter) writeHeader(p []byte) {
-	if cw.wroteHeader {
-		return
-	}
-	cw.wroteHeader = true
-
-	w := cw.res
-	keepAlivesEnabled := w.conn.server.doKeepAlives()
-	isHEAD := w.req.Method == "HEAD"
-
-	// header is written out to w.conn.buf below. Depending on the
-	// state of the handler, we either own the map or not. If we
-	// don't own it, the exclude map is created lazily for
-	// WriteSubset to remove headers. The setHeader struct holds
-	// headers we need to add.
-	header := cw.header
-	owned := header != nil
-	if !owned {
-		header = w.handlerHeader
-	}
-	var excludeHeader map[string]bool
-	delHeader := func(key string) {
-		if owned {
-			header.Del(key)
-			return
-		}
-		if _, ok := header[key]; !ok {
-			return
-		}
-		if excludeHeader == nil {
-			excludeHeader = make(map[string]bool)
-		}
-		excludeHeader[key] = true
-	}
-	var setHeader extraHeader
-
-	// If the handler is done but never sent a Content-Length
-	// response header and this is our first (and last) write, set
-	// it, even to zero. This helps HTTP/1.0 clients keep their
-	// "keep-alive" connections alive.
-	// Exceptions: 304/204/1xx responses never get Content-Length, and if
-	// it was a HEAD request, we don't know the difference between
-	// 0 actual bytes and 0 bytes because the handler noticed it
-	// was a HEAD request and chose not to write anything.  So for
-	// HEAD, the handler should either write the Content-Length or
-	// write non-zero bytes.  If it's actually 0 bytes and the
-	// handler never looked at the Request.Method, we just don't
-	// send a Content-Length header.
-	if w.handlerDone && bodyAllowedForStatus(w.status) && header.get("Content-Length") == "" && (!isHEAD || len(p) > 0) {
-		w.contentLength = int64(len(p))
-		setHeader.contentLength = strconv.AppendInt(cw.res.clenBuf[:0], int64(len(p)), 10)
-	}
-
-	// If this was an HTTP/1.0 request with keep-alive and we sent a
-	// Content-Length back, we can make this a keep-alive response ...
-	if w.req.wantsHttp10KeepAlive() && keepAlivesEnabled {
-		sentLength := header.get("Content-Length") != ""
-		if sentLength && header.get("Connection") == "keep-alive" {
-			w.closeAfterReply = false
-		}
-	}
-
-	// Check for a explicit (and valid) Content-Length header.
-	hasCL := w.contentLength != -1
-
-	if w.req.wantsHttp10KeepAlive() && (isHEAD || hasCL) {
-		_, connectionHeaderSet := header["Connection"]
-		if !connectionHeaderSet {
-			setHeader.connection = "keep-alive"
-		}
-	} else if !w.req.ProtoAtLeast(1, 1) || w.req.wantsClose() {
-		w.closeAfterReply = true
-	}
-
-	if header.get("Connection") == "close" || !keepAlivesEnabled {
-		w.closeAfterReply = true
-	}
-
-	// Per RFC 2616, we should consume the request body before
-	// replying, if the handler hasn't already done so.  But we
-	// don't want to do an unbounded amount of reading here for
-	// DoS reasons, so we only try up to a threshold.
-	if w.req.ContentLength != 0 && !w.closeAfterReply {
-		ecr, isExpecter := w.req.Body.(*expectContinueReader)
-		if !isExpecter || ecr.resp.wroteContinue {
-			n, _ := io.CopyN(ioutil.Discard, w.req.Body, maxPostHandlerReadBytes+1)
-			if n >= maxPostHandlerReadBytes {
-				w.requestTooLarge()
-				delHeader("Connection")
-				setHeader.connection = "close"
-			} else {
-				w.req.Body.Close()
-			}
-		}
-	}
-
-	code := w.status
-	if bodyAllowedForStatus(code) {
-		// If no content type, apply sniffing algorithm to body.
-		_, haveType := header["Content-Type"]
-		if !haveType {
-			setHeader.contentType = DetectContentType(p)
-		}
-	} else {
-		for _, k := range suppressedHeaders(code) {
-			delHeader(k)
-		}
-	}
-
-	if _, ok := header["Date"]; !ok {
-		setHeader.date = appendTime(cw.res.dateBuf[:0], time.Now())
-	}
-
-	te := header.get("Transfer-Encoding")
-	hasTE := te != ""
-	if hasCL && hasTE && te != "identity" {
-		// TODO: return an error if WriteHeader gets a return parameter
-		// For now just ignore the Content-Length.
-		w.conn.server.logf("http: WriteHeader called with both Transfer-Encoding of %q and a Content-Length of %d",
-			te, w.contentLength)
-		delHeader("Content-Length")
-		hasCL = false
-	}
-
-	if w.req.Method == "HEAD" || !bodyAllowedForStatus(code) {
-		// do nothing
-	} else if code == StatusNoContent {
-		delHeader("Transfer-Encoding")
-	} else if hasCL {
-		delHeader("Transfer-Encoding")
-	} else if w.req.ProtoAtLeast(1, 1) {
-		// HTTP/1.1 or greater: use chunked transfer encoding
-		// to avoid closing the connection at EOF.
-		// TODO: this blows away any custom or stacked Transfer-Encoding they
-		// might have set.  Deal with that as need arises once we have a valid
-		// use case.
-		cw.chunking = true
-		setHeader.transferEncoding = "chunked"
-	} else {
-		// HTTP version < 1.1: cannot do chunked transfer
-		// encoding and we don't know the Content-Length so
-		// signal EOF by closing connection.
-		w.closeAfterReply = true
-		delHeader("Transfer-Encoding") // in case already set
-	}
-
-	// Cannot use Content-Length with non-identity Transfer-Encoding.
-	if cw.chunking {
-		delHeader("Content-Length")
-	}
-	if !w.req.ProtoAtLeast(1, 0) {
-		return
-	}
-
-	if w.closeAfterReply && (!keepAlivesEnabled || !hasToken(cw.header.get("Connection"), "close")) {
-		delHeader("Connection")
-		if w.req.ProtoAtLeast(1, 1) {
-			setHeader.connection = "close"
-		}
-	}
-
-	w.conn.buf.WriteString(statusLine(w.req, code))
-	cw.header.WriteSubset(w.conn.buf, excludeHeader)
-	setHeader.Write(w.conn.buf.Writer)
-	w.conn.buf.Write(crlf)
-}
-
-// statusLines is a cache of Status-Line strings, keyed by code (for
-// HTTP/1.1) or negative code (for HTTP/1.0). This is faster than a
-// map keyed by struct of two fields. This map's max size is bounded
-// by 2*len(statusText), two protocol types for each known official
-// status code in the statusText map.
-var (
-	statusMu    sync.RWMutex
-	statusLines = make(map[int]string)
-)
-
-// statusLine returns a response Status-Line (RFC 2616 Section 6.1)
-// for the given request and response status code.
-func statusLine(req *Request, code int) string {
-	// Fast path:
-	key := code
-	proto11 := req.ProtoAtLeast(1, 1)
-	if !proto11 {
-		key = -key
-	}
-	statusMu.RLock()
-	line, ok := statusLines[key]
-	statusMu.RUnlock()
-	if ok {
-		return line
-	}
-
-	// Slow path:
-	proto := "HTTP/1.0"
-	if proto11 {
-		proto = "HTTP/1.1"
-	}
-	codestring := strconv.Itoa(code)
-	text, ok := statusText[code]
-	if !ok {
-		text = "status code " + codestring
-	}
-	line = proto + " " + codestring + " " + text + "\r\n"
-	if ok {
-		statusMu.Lock()
-		defer statusMu.Unlock()
-		statusLines[key] = line
-	}
-	return line
-}
-
-// bodyAllowed returns true if a Write is allowed for this response type.
-// It's illegal to call this before the header has been flushed.
-func (w *response) bodyAllowed() bool {
-	if !w.wroteHeader {
-		panic("")
-	}
-	return bodyAllowedForStatus(w.status)
-}
-
-// The Life Of A Write is like this:
-//
-// Handler starts. No header has been sent. The handler can either
-// write a header, or just start writing.  Writing before sending a header
-// sends an implicitly empty 200 OK header.
-//
-// If the handler didn't declare a Content-Length up front, we either
-// go into chunking mode or, if the handler finishes running before
-// the chunking buffer size, we compute a Content-Length and send that
-// in the header instead.
-//
-// Likewise, if the handler didn't set a Content-Type, we sniff that
-// from the initial chunk of output.
-//
-// The Writers are wired together like:
-//
-// 1. *response (the ResponseWriter) ->
-// 2. (*response).w, a *bufio.Writer of bufferBeforeChunkingSize bytes
-// 3. chunkWriter.Writer (whose writeHeader finalizes Content-Length/Type)
-//    and which writes the chunk headers, if needed.
-// 4. conn.buf, a bufio.Writer of default (4kB) bytes
-// 5. the rwc, the net.Conn.
-//
-// TODO(bradfitz): short-circuit some of the buffering when the
-// initial header contains both a Content-Type and Content-Length.
-// Also short-circuit in (1) when the header's been sent and not in
-// chunking mode, writing directly to (4) instead, if (2) has no
-// buffered data.  More generally, we could short-circuit from (1) to
-// (3) even in chunking mode if the write size from (1) is over some
-// threshold and nothing is in (2).  The answer might be mostly making
-// bufferBeforeChunkingSize smaller and having bufio's fast-paths deal
-// with this instead.
-func (w *response) Write(data []byte) (n int, err error) {
-	return w.write(len(data), data, "")
-}
-
-func (w *response) WriteString(data string) (n int, err error) {
-	return w.write(len(data), nil, data)
-}
-
-// either dataB or dataS is non-zero.
-func (w *response) write(lenData int, dataB []byte, dataS string) (n int, err error) {
-	if w.conn.hijacked() {
-		w.conn.server.logf("http: response.Write on hijacked connection")
-		return 0, ErrHijacked
-	}
-	if !w.wroteHeader {
-		w.WriteHeader(StatusOK)
-	}
-	if lenData == 0 {
-		return 0, nil
-	}
-	if !w.bodyAllowed() {
-		return 0, ErrBodyNotAllowed
-	}
-
-	w.written += int64(lenData) // ignoring errors, for errorKludge
-	if w.contentLength != -1 && w.written > w.contentLength {
-		return 0, ErrContentLength
-	}
-	if dataB != nil {
-		return w.w.Write(dataB)
-	} else {
-		return w.w.WriteString(dataS)
-	}
-}
-
-func (w *response) finishRequest() {
-	w.handlerDone = true
-
-	if !w.wroteHeader {
-		w.WriteHeader(StatusOK)
-	}
-
-	w.w.Flush()
-	putBufioWriter(w.w)
-	w.cw.close()
-	w.conn.buf.Flush()
-
-	// Close the body (regardless of w.closeAfterReply) so we can
-	// re-use its bufio.Reader later safely.
-	w.req.Body.Close()
-
-	if w.req.MultipartForm != nil {
-		w.req.MultipartForm.RemoveAll()
-	}
-
-	if w.req.Method != "HEAD" && w.contentLength != -1 && w.bodyAllowed() && w.contentLength != w.written {
-		// Did not write enough. Avoid getting out of sync.
-		w.closeAfterReply = true
-	}
-}
-
-func (w *response) Flush() {
-	if !w.wroteHeader {
-		w.WriteHeader(StatusOK)
-	}
-	w.w.Flush()
-	w.cw.flush()
-}
-
-func (c *conn) finalFlush() {
-	if c.buf != nil {
-		c.buf.Flush()
-
-		// Steal the bufio.Reader (~4KB worth of memory) and its associated
-		// reader for a future connection.
-		putBufioReader(c.buf.Reader)
-
-		// Steal the bufio.Writer (~4KB worth of memory) and its associated
-		// writer for a future connection.
-		putBufioWriter(c.buf.Writer)
-
-		c.buf = nil
-	}
-}
-
-// Close the connection.
-func (c *conn) close() {
-	c.finalFlush()
-	if c.rwc != nil {
-		c.rwc.Close()
-		c.rwc = nil
-	}
-}
-
-// rstAvoidanceDelay is the amount of time we sleep after closing the
-// write side of a TCP connection before closing the entire socket.
-// By sleeping, we increase the chances that the client sees our FIN
-// and processes its final data before they process the subsequent RST
-// from closing a connection with known unread data.
-// This RST seems to occur mostly on BSD systems. (And Windows?)
-// This timeout is somewhat arbitrary (~latency around the planet).
-const rstAvoidanceDelay = 500 * time.Millisecond
-
-// closeWrite flushes any outstanding data and sends a FIN packet (if
-// client is connected via TCP), signalling that we're done.  We then
-// pause for a bit, hoping the client processes it before `any
-// subsequent RST.
-//
-// See http://golang.org/issue/3595
-func (c *conn) closeWriteAndWait() {
-	c.finalFlush()
-	if tcp, ok := c.rwc.(*net.TCPConn); ok {
-		tcp.CloseWrite()
-	}
-	time.Sleep(rstAvoidanceDelay)
-}
-
-// validNPN reports whether the proto is not a blacklisted Next
-// Protocol Negotiation protocol.  Empty and built-in protocol types
-// are blacklisted and can't be overridden with alternate
-// implementations.
-func validNPN(proto string) bool {
-	switch proto {
-	case "", "http/1.1", "http/1.0":
-		return false
-	}
-	return true
-}
-
-func (c *conn) setState(nc net.Conn, state ConnState) {
-	if hook := c.server.ConnState; hook != nil {
-		hook(nc, state)
-	}
-}
-
-// Serve a new connection.
-func (c *conn) serve() {
-	origConn := c.rwc // copy it before it's set nil on Close or Hijack
-	defer func() {
-		if err := recover(); err != nil {
-			const size = 64 << 10
-			buf := make([]byte, size)
-			buf = buf[:runtime.Stack(buf, false)]
-			c.server.logf("http: panic serving %v: %v\n%s", c.remoteAddr, err, buf)
-		}
-		if !c.hijacked() {
-			c.close()
-			c.setState(origConn, StateClosed)
-		}
-	}()
-
-	if tlsConn, ok := c.rwc.(*tls.Conn); ok {
-		if d := c.server.ReadTimeout; d != 0 {
-			c.rwc.SetReadDeadline(time.Now().Add(d))
-		}
-		if d := c.server.WriteTimeout; d != 0 {
-			c.rwc.SetWriteDeadline(time.Now().Add(d))
-		}
-		if err := tlsConn.Handshake(); err != nil {
-			c.server.logf("http: TLS handshake error from %s: %v", c.rwc.RemoteAddr(), err)
-			return
-		}
-		c.tlsState = new(tls.ConnectionState)
-		*c.tlsState = tlsConn.ConnectionState()
-		if proto := c.tlsState.NegotiatedProtocol; validNPN(proto) {
-			if fn := c.server.TLSNextProto[proto]; fn != nil {
-				h := initNPNRequest{tlsConn, serverHandler{c.server}}
-				fn(c.server, tlsConn, h)
-			}
-			return
-		}
-	}
-
-	for {
-		w, err := c.readRequest()
-		if c.lr.N != c.server.initialLimitedReaderSize() {
-			// If we read any bytes off the wire, we're active.
-			c.setState(c.rwc, StateActive)
-		}
-		if err != nil {
-			if err == errTooLarge {
-				// Their HTTP client may or may not be
-				// able to read this if we're
-				// responding to them and hanging up
-				// while they're still writing their
-				// request.  Undefined behavior.
-				io.WriteString(c.rwc, "HTTP/1.1 413 Request Entity Too Large\r\n\r\n")
-				c.closeWriteAndWait()
-				break
-			} else if err == io.EOF {
-				break // Don't reply
-			} else if neterr, ok := err.(net.Error); ok && neterr.Timeout() {
-				break // Don't reply
-			}
-			io.WriteString(c.rwc, "HTTP/1.1 400 Bad Request\r\n\r\n")
-			break
-		}
-
-		// Expect 100 Continue support
-		req := w.req
-		if req.expectsContinue() {
-			if req.ProtoAtLeast(1, 1) && req.ContentLength != 0 {
-				// Wrap the Body reader with one that replies on the connection
-				req.Body = &expectContinueReader{readCloser: req.Body, resp: w}
-			}
-			req.Header.Del("Expect")
-		} else if req.Header.get("Expect") != "" {
-			w.sendExpectationFailed()
-			break
-		}
-
-		// HTTP cannot have multiple simultaneous active requests.[*]
-		// Until the server replies to this request, it can't read another,
-		// so we might as well run the handler in this goroutine.
-		// [*] Not strictly true: HTTP pipelining.  We could let them all process
-		// in parallel even if their responses need to be serialized.
-		serverHandler{c.server}.ServeHTTP(w, w.req)
-		if c.hijacked() {
-			return
-		}
-		w.finishRequest()
-		if w.closeAfterReply {
-			if w.requestBodyLimitHit {
-				c.closeWriteAndWait()
-			}
-			break
-		}
-		c.setState(c.rwc, StateIdle)
-	}
-}
-
-func (w *response) sendExpectationFailed() {
-	// TODO(bradfitz): let ServeHTTP handlers handle
-	// requests with non-standard expectation[s]? Seems
-	// theoretical at best, and doesn't fit into the
-	// current ServeHTTP model anyway.  We'd need to
-	// make the ResponseWriter an optional
-	// "ExpectReplier" interface or something.
-	//
-	// For now we'll just obey RFC 2616 14.20 which says
-	// "If a server receives a request containing an
-	// Expect field that includes an expectation-
-	// extension that it does not support, it MUST
-	// respond with a 417 (Expectation Failed) status."
-	w.Header().Set("Connection", "close")
-	w.WriteHeader(StatusExpectationFailed)
-	w.finishRequest()
-}
-
-// Hijack implements the Hijacker.Hijack method. Our response is both a ResponseWriter
-// and a Hijacker.
-func (w *response) Hijack() (rwc net.Conn, buf *bufio.ReadWriter, err error) {
-	if w.wroteHeader {
-		w.cw.flush()
-	}
-	// Release the bufioWriter that writes to the chunk writer, it is not
-	// used after a connection has been hijacked.
-	rwc, buf, err = w.conn.hijack()
-	if err == nil {
-		putBufioWriter(w.w)
-		w.w = nil
-	}
-	return rwc, buf, err
-}
-
-func (w *response) CloseNotify() <-chan bool {
-	return w.conn.closeNotify()
-}
-
-// The HandlerFunc type is an adapter to allow the use of
-// ordinary functions as HTTP handlers.  If f is a function
-// with the appropriate signature, HandlerFunc(f) is a
-// Handler object that calls f.
-type HandlerFunc func(ResponseWriter, *Request)
-
-// ServeHTTP calls f(w, r).
-func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
-	f(w, r)
-}
-
-// Helper handlers
-
-// Error replies to the request with the specified error message and HTTP code.
-// The error message should be plain text.
-func Error(w ResponseWriter, error string, code int) {
-	w.Header().Set("Content-Type", "text/plain; charset=utf-8")
-	w.WriteHeader(code)
-	fmt.Fprintln(w, error)
-}
-
-// NotFound replies to the request with an HTTP 404 not found error.
-func NotFound(w ResponseWriter, r *Request) { Error(w, "404 page not found", StatusNotFound) }
-
-// NotFoundHandler returns a simple request handler
-// that replies to each request with a ``404 page not found'' reply.
-func NotFoundHandler() Handler { return HandlerFunc(NotFound) }
-
-// StripPrefix returns a handler that serves HTTP requests
-// by removing the given prefix from the request URL's Path
-// and invoking the handler h. StripPrefix handles a
-// request for a path that doesn't begin with prefix by
-// replying with an HTTP 404 not found error.
-func StripPrefix(prefix string, h Handler) Handler {
-	if prefix == "" {
-		return h
-	}
-	return HandlerFunc(func(w ResponseWriter, r *Request) {
-		if p := strings.TrimPrefix(r.URL.Path, prefix); len(p) < len(r.URL.Path) {
-			r.URL.Path = p
-			h.ServeHTTP(w, r)
-		} else {
-			NotFound(w, r)
-		}
-	})
-}
-
-// Redirect replies to the request with a redirect to url,
-// which may be a path relative to the request path.
-func Redirect(w ResponseWriter, r *Request, urlStr string, code int) {
-	if u, err := url.Parse(urlStr); err == nil {
-		// If url was relative, make absolute by
-		// combining with request path.
-		// The browser would probably do this for us,
-		// but doing it ourselves is more reliable.
-
-		// NOTE(rsc): RFC 2616 says that the Location
-		// line must be an absolute URI, like
-		// "http://www.google.com/redirect/",
-		// not a path like "/redirect/".
-		// Unfortunately, we don't know what to
-		// put in the host name section to get the
-		// client to connect to us again, so we can't
-		// know the right absolute URI to send back.
-		// Because of this problem, no one pays attention
-		// to the RFC; they all send back just a new path.
-		// So do we.
-		oldpath := r.URL.Path
-		if oldpath == "" { // should not happen, but avoid a crash if it does
-			oldpath = "/"
-		}
-		if u.Scheme == "" {
-			// no leading http://server
-			if urlStr == "" || urlStr[0] != '/' {
-				// make relative path absolute
-				olddir, _ := path.Split(oldpath)
-				urlStr = olddir + urlStr
-			}
-
-			var query string
-			if i := strings.Index(urlStr, "?"); i != -1 {
-				urlStr, query = urlStr[:i], urlStr[i:]
-			}
-
-			// clean up but preserve trailing slash
-			trailing := strings.HasSuffix(urlStr, "/")
-			urlStr = path.Clean(urlStr)
-			if trailing && !strings.HasSuffix(urlStr, "/") {
-				urlStr += "/"
-			}
-			urlStr += query
-		}
-	}
-
-	w.Header().Set("Location", urlStr)
-	w.WriteHeader(code)
-
-	// RFC2616 recommends that a short note "SHOULD" be included in the
-	// response because older user agents may not understand 301/307.
-	// Shouldn't send the response for POST or HEAD; that leaves GET.
-	if r.Method == "GET" {
-		note := "<a href=\"" + htmlEscape(urlStr) + "\">" + statusText[code] + "</a>.\n"
-		fmt.Fprintln(w, note)
-	}
-}
-
-var htmlReplacer = strings.NewReplacer(
-	"&", "&amp;",
-	"<", "&lt;",
-	">", "&gt;",
-	// "&#34;" is shorter than "&quot;".
-	`"`, "&#34;",
-	// "&#39;" is shorter than "&apos;" and apos was not in HTML until HTML5.
-	"'", "&#39;",
-)
-
-func htmlEscape(s string) string {
-	return htmlReplacer.Replace(s)
-}
-
-// Redirect to a fixed URL
-type redirectHandler struct {
-	url  string
-	code int
-}
-
-func (rh *redirectHandler) ServeHTTP(w ResponseWriter, r *Request) {
-	Redirect(w, r, rh.url, rh.code)
-}
-
-// RedirectHandler returns a request handler that redirects
-// each request it receives to the given url using the given
-// status code.
-func RedirectHandler(url string, code int) Handler {
-	return &redirectHandler{url, code}
-}
-
-// ServeMux is an HTTP request multiplexer.
-// It matches the URL of each incoming request against a list of registered
-// patterns and calls the handler for the pattern that
-// most closely matches the URL.
-//
-// Patterns name fixed, rooted paths, like "/favicon.ico",
-// or rooted subtrees, like "/images/" (note the trailing slash).
-// Longer patterns take precedence over shorter ones, so that
-// if there are handlers registered for both "/images/"
-// and "/images/thumbnails/", the latter handler will be
-// called for paths beginning "/images/thumbnails/" and the
-// former will receive requests for any other paths in the
-// "/images/" subtree.
-//
-// Note that since a pattern ending in a slash names a rooted subtree,
-// the pattern "/" matches all paths not matched by other registered
-// patterns, not just the URL with Path == "/".
-//
-// Patterns may optionally begin with a host name, restricting matches to
-// URLs on that host only.  Host-specific patterns take precedence over
-// general patterns, so that a handler might register for the two patterns
-// "/codesearch" and "codesearch.google.com/" without also taking over
-// requests for "http://www.google.com/".
-//
-// ServeMux also takes care of sanitizing the URL request path,
-// redirecting any request containing . or .. elements to an
-// equivalent .- and ..-free URL.
-type ServeMux struct {
-	mu    sync.RWMutex
-	m     map[string]muxEntry
-	hosts bool // whether any patterns contain hostnames
-}
-
-type muxEntry struct {
-	explicit bool
-	h        Handler
-	pattern  string
-}
-
-// NewServeMux allocates and returns a new ServeMux.
-func NewServeMux() *ServeMux { return &ServeMux{m: make(map[string]muxEntry)} }
-
-// DefaultServeMux is the default ServeMux used by Serve.
-var DefaultServeMux = NewServeMux()
-
-// Does path match pattern?
-func pathMatch(pattern, path string) bool {
-	if len(pattern) == 0 {
-		// should not happen
-		return false
-	}
-	n := len(pattern)
-	if pattern[n-1] != '/' {
-		return pattern == path
-	}
-	return len(path) >= n && path[0:n] == pattern
-}
-
-// Return the canonical path for p, eliminating . and .. elements.
-func cleanPath(p string) string {
-	if p == "" {
-		return "/"
-	}
-	if p[0] != '/' {
-		p = "/" + p
-	}
-	np := path.Clean(p)
-	// path.Clean removes trailing slash except for root;
-	// put the trailing slash back if necessary.
-	if p[len(p)-1] == '/' && np != "/" {
-		np += "/"
-	}
-	return np
-}
-
-// Find a handler on a handler map given a path string
-// Most-specific (longest) pattern wins
-func (mux *ServeMux) match(path string) (h Handler, pattern string) {
-	var n = 0
-	for k, v := range mux.m {
-		if !pathMatch(k, path) {
-			continue
-		}
-		if h == nil || len(k) > n {
-			n = len(k)
-			h = v.h
-			pattern = v.pattern
-		}
-	}
-	return
-}
-
-// Handler returns the handler to use for the given request,
-// consulting r.Method, r.Host, and r.URL.Path. It always returns
-// a non-nil handler. If the path is not in its canonical form, the
-// handler will be an internally-generated handler that redirects
-// to the canonical path.
-//
-// Handler also returns the registered pattern that matches the
-// request or, in the case of internally-generated redirects,
-// the pattern that will match after following the redirect.
-//
-// If there is no registered handler that applies to the request,
-// Handler returns a ``page not found'' handler and an empty pattern.
-func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {
-	if r.Method != "CONNECT" {
-		if p := cleanPath(r.URL.Path); p != r.URL.Path {
-			_, pattern = mux.handler(r.Host, p)
-			url := *r.URL
-			url.Path = p
-			return RedirectHandler(url.String(), StatusMovedPermanently), pattern
-		}
-	}
-
-	return mux.handler(r.Host, r.URL.Path)
-}
-
-// handler is the main implementation of Handler.
-// The path is known to be in canonical form, except for CONNECT methods.
-func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {
-	mux.mu.RLock()
-	defer mux.mu.RUnlock()
-
-	// Host-specific pattern takes precedence over generic ones
-	if mux.hosts {
-		h, pattern = mux.match(host + path)
-	}
-	if h == nil {
-		h, pattern = mux.match(path)
-	}
-	if h == nil {
-		h, pattern = NotFoundHandler(), ""
-	}
-	return
-}
-
-// ServeHTTP dispatches the request to the handler whose
-// pattern most closely matches the request URL.
-func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {
-	if r.RequestURI == "*" {
-		if r.ProtoAtLeast(1, 1) {
-			w.Header().Set("Connection", "close")
-		}
-		w.WriteHeader(StatusBadRequest)
-		return
-	}
-	h, _ := mux.Handler(r)
-	h.ServeHTTP(w, r)
-}
-
-// Handle registers the handler for the given pattern.
-// If a handler already exists for pattern, Handle panics.
-func (mux *ServeMux) Handle(pattern string, handler Handler) {
-	mux.mu.Lock()
-	defer mux.mu.Unlock()
-
-	if pattern == "" {
-		panic("http: invalid pattern " + pattern)
-	}
-	if handler == nil {
-		panic("http: nil handler")
-	}
-	if mux.m[pattern].explicit {
-		panic("http: multiple registrations for " + pattern)
-	}
-
-	mux.m[pattern] = muxEntry{explicit: true, h: handler, pattern: pattern}
-
-	if pattern[0] != '/' {
-		mux.hosts = true
-	}
-
-	// Helpful behavior:
-	// If pattern is /tree/, insert an implicit permanent redirect for /tree.
-	// It can be overridden by an explicit registration.
-	n := len(pattern)
-	if n > 0 && pattern[n-1] == '/' && !mux.m[pattern[0:n-1]].explicit {
-		// If pattern contains a host name, strip it and use remaining
-		// path for redirect.
-		path := pattern
-		if pattern[0] != '/' {
-			// In pattern, at least the last character is a '/', so
-			// strings.Index can't be -1.
-			path = pattern[strings.Index(pattern, "/"):]
-		}
-		mux.m[pattern[0:n-1]] = muxEntry{h: RedirectHandler(path, StatusMovedPermanently), pattern: pattern}
-	}
-}
-
-// HandleFunc registers the handler function for the given pattern.
-func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
-	mux.Handle(pattern, HandlerFunc(handler))
-}
-
-// Handle registers the handler for the given pattern
-// in the DefaultServeMux.
-// The documentation for ServeMux explains how patterns are matched.
-func Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }
-
-// HandleFunc registers the handler function for the given pattern
-// in the DefaultServeMux.
-// The documentation for ServeMux explains how patterns are matched.
-func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
-	DefaultServeMux.HandleFunc(pattern, handler)
-}
-
-// Serve accepts incoming HTTP connections on the listener l,
-// creating a new service goroutine for each.  The service goroutines
-// read requests and then call handler to reply to them.
-// Handler is typically nil, in which case the DefaultServeMux is used.
-func Serve(l net.Listener, handler Handler) error {
-	srv := &Server{Handler: handler}
-	return srv.Serve(l)
-}
-
-// A Server defines parameters for running an HTTP server.
-// The zero value for Server is a valid configuration.
-type Server struct {
-	Addr           string        // TCP address to listen on, ":http" if empty
-	Handler        Handler       // handler to invoke, http.DefaultServeMux if nil
-	ReadTimeout    time.Duration // maximum duration before timing out read of the request
-	WriteTimeout   time.Duration // maximum duration before timing out write of the response
-	MaxHeaderBytes int           // maximum size of request headers, DefaultMaxHeaderBytes if 0
-	TLSConfig      *tls.Config   // optional TLS config, used by ListenAndServeTLS
-
-	// TLSNextProto optionally specifies a function to take over
-	// ownership of the provided TLS connection when an NPN
-	// protocol upgrade has occurred.  The map key is the protocol
-	// name negotiated. The Handler argument should be used to
-	// handle HTTP requests and will initialize the Request's TLS
-	// and RemoteAddr if not already set.  The connection is
-	// automatically closed when the function returns.
-	TLSNextProto map[string]func(*Server, *tls.Conn, Handler)
-
-	// ConnState specifies an optional callback function that is
-	// called when a client connection changes state. See the
-	// ConnState type and associated constants for details.
-	ConnState func(net.Conn, ConnState)
-
-	// ErrorLog specifies an optional logger for errors accepting
-	// connections and unexpected behavior from handlers.
-	// If nil, logging goes to os.Stderr via the log package's
-	// standard logger.
-	ErrorLog *log.Logger
-
-	disableKeepAlives int32 // accessed atomically.
-}
-
-// A ConnState represents the state of a client connection to a server.
-// It's used by the optional Server.ConnState hook.
-type ConnState int
-
-const (
-	// StateNew represents a new connection that is expected to
-	// send a request immediately. Connections begin at this
-	// state and then transition to either StateActive or
-	// StateClosed.
-	StateNew ConnState = iota
-
-	// StateActive represents a connection that has read 1 or more
-	// bytes of a request. The Server.ConnState hook for
-	// StateActive fires before the request has entered a handler
-	// and doesn't fire again until the request has been
-	// handled. After the request is handled, the state
-	// transitions to StateClosed, StateHijacked, or StateIdle.
-	StateActive
-
-	// StateIdle represents a connection that has finished
-	// handling a request and is in the keep-alive state, waiting
-	// for a new request. Connections transition from StateIdle
-	// to either StateActive or StateClosed.
-	StateIdle
-
-	// StateHijacked represents a hijacked connection.
-	// This is a terminal state. It does not transition to StateClosed.
-	StateHijacked
-
-	// StateClosed represents a closed connection.
-	// This is a terminal state. Hijacked connections do not
-	// transition to StateClosed.
-	StateClosed
-)
-
-var stateName = map[ConnState]string{
-	StateNew:      "new",
-	StateActive:   "active",
-	StateIdle:     "idle",
-	StateHijacked: "hijacked",
-	StateClosed:   "closed",
-}
-
-func (c ConnState) String() string {
-	return stateName[c]
-}
-
-// serverHandler delegates to either the server's Handler or
-// DefaultServeMux and also handles "OPTIONS *" requests.
-type serverHandler struct {
-	srv *Server
-}
-
-func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {
-	handler := sh.srv.Handler
-	if handler == nil {
-		handler = DefaultServeMux
-	}
-	if req.RequestURI == "*" && req.Method == "OPTIONS" {
-		handler = globalOptionsHandler{}
-	}
-	handler.ServeHTTP(rw, req)
-}
-
-// ListenAndServe listens on the TCP network address srv.Addr and then
-// calls Serve to handle requests on incoming connections.  If
-// srv.Addr is blank, ":http" is used.
-func (srv *Server) ListenAndServe() error {
-	addr := srv.Addr
-	if addr == "" {
-		addr = ":http"
-	}
-	ln, err := net.Listen("tcp", addr)
-	if err != nil {
-		return err
-	}
-	return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})
-}
-
-// Serve accepts incoming connections on the Listener l, creating a
-// new service goroutine for each.  The service goroutines read requests and
-// then call srv.Handler to reply to them.
-func (srv *Server) Serve(l net.Listener) error {
-	defer l.Close()
-	var tempDelay time.Duration // how long to sleep on accept failure
-	for {
-		rw, e := l.Accept()
-		if e != nil {
-			if ne, ok := e.(net.Error); ok && ne.Temporary() {
-				if tempDelay == 0 {
-					tempDelay = 5 * time.Millisecond
-				} else {
-					tempDelay *= 2
-				}
-				if max := 1 * time.Second; tempDelay > max {
-					tempDelay = max
-				}
-				srv.logf("http: Accept error: %v; retrying in %v", e, tempDelay)
-				time.Sleep(tempDelay)
-				continue
-			}
-			return e
-		}
-		tempDelay = 0
-		c, err := srv.newConn(rw)
-		if err != nil {
-			continue
-		}
-		c.setState(c.rwc, StateNew) // before Serve can return
-		go c.serve()
-	}
-}
-
-func (s *Server) doKeepAlives() bool {
-	return atomic.LoadInt32(&s.disableKeepAlives) == 0
-}
-
-// SetKeepAlivesEnabled controls whether HTTP keep-alives are enabled.
-// By default, keep-alives are always enabled. Only very
-// resource-constrained environments or servers in the process of
-// shutting down should disable them.
-func (s *Server) SetKeepAlivesEnabled(v bool) {
-	if v {
-		atomic.StoreInt32(&s.disableKeepAlives, 0)
-	} else {
-		atomic.StoreInt32(&s.disableKeepAlives, 1)
-	}
-}
-
-func (s *Server) logf(format string, args ...interface{}) {
-	if s.ErrorLog != nil {
-		s.ErrorLog.Printf(format, args...)
-	} else {
-		log.Printf(format, args...)
-	}
-}
-
-// ListenAndServe listens on the TCP network address addr
-// and then calls Serve with handler to handle requests
-// on incoming connections.  Handler is typically nil,
-// in which case the DefaultServeMux is used.
-//
-// A trivial example server is:
-//
-//	package main
-//
-//	import (
-//		"io"
-//		"github.com/ubports/ubuntu-push/http13client"
-//		"log"
-//	)
-//
-//	// hello world, the web server
-//	func HelloServer(w http.ResponseWriter, req *http.Request) {
-//		io.WriteString(w, "hello, world!\n")
-//	}
-//
-//	func main() {
-//		http.HandleFunc("/hello", HelloServer)
-//		err := http.ListenAndServe(":12345", nil)
-//		if err != nil {
-//			log.Fatal("ListenAndServe: ", err)
-//		}
-//	}
-func ListenAndServe(addr string, handler Handler) error {
-	server := &Server{Addr: addr, Handler: handler}
-	return server.ListenAndServe()
-}
-
-// ListenAndServeTLS acts identically to ListenAndServe, except that it
-// expects HTTPS connections. Additionally, files containing a certificate and
-// matching private key for the server must be provided. If the certificate
-// is signed by a certificate authority, the certFile should be the concatenation
-// of the server's certificate followed by the CA's certificate.
-//
-// A trivial example server is:
-//
-//	import (
-//		"log"
-//		"github.com/ubports/ubuntu-push/http13client"
-//	)
-//
-//	func handler(w http.ResponseWriter, req *http.Request) {
-//		w.Header().Set("Content-Type", "text/plain")
-//		w.Write([]byte("This is an example server.\n"))
-//	}
-//
-//	func main() {
-//		http.HandleFunc("/", handler)
-//		log.Printf("About to listen on 10443. Go to https://127.0.0.1:10443/")
-//		err := http.ListenAndServeTLS(":10443", "cert.pem", "key.pem", nil)
-//		if err != nil {
-//			log.Fatal(err)
-//		}
-//	}
-//
-// One can use generate_cert.go in crypto/tls to generate cert.pem and key.pem.
-func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Handler) error {
-	server := &Server{Addr: addr, Handler: handler}
-	return server.ListenAndServeTLS(certFile, keyFile)
-}
-
-// ListenAndServeTLS listens on the TCP network address srv.Addr and
-// then calls Serve to handle requests on incoming TLS connections.
-//
-// Filenames containing a certificate and matching private key for
-// the server must be provided. If the certificate is signed by a
-// certificate authority, the certFile should be the concatenation
-// of the server's certificate followed by the CA's certificate.
-//
-// If srv.Addr is blank, ":https" is used.
-func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error {
-	addr := srv.Addr
-	if addr == "" {
-		addr = ":https"
-	}
-	config := &tls.Config{}
-	if srv.TLSConfig != nil {
-		*config = *srv.TLSConfig
-	}
-	if config.NextProtos == nil {
-		config.NextProtos = []string{"http/1.1"}
-	}
-
-	var err error
-	config.Certificates = make([]tls.Certificate, 1)
-	config.Certificates[0], err = tls.LoadX509KeyPair(certFile, keyFile)
-	if err != nil {
-		return err
-	}
-
-	ln, err := net.Listen("tcp", addr)
-	if err != nil {
-		return err
-	}
-
-	tlsListener := tls.NewListener(tcpKeepAliveListener{ln.(*net.TCPListener)}, config)
-	return srv.Serve(tlsListener)
-}
-
-// TimeoutHandler returns a Handler that runs h with the given time limit.
-//
-// The new Handler calls h.ServeHTTP to handle each request, but if a
-// call runs for longer than its time limit, the handler responds with
-// a 503 Service Unavailable error and the given message in its body.
-// (If msg is empty, a suitable default message will be sent.)
-// After such a timeout, writes by h to its ResponseWriter will return
-// ErrHandlerTimeout.
-func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler {
-	f := func() <-chan time.Time {
-		return time.After(dt)
-	}
-	return &timeoutHandler{h, f, msg}
-}
-
-// ErrHandlerTimeout is returned on ResponseWriter Write calls
-// in handlers which have timed out.
-var ErrHandlerTimeout = errors.New("http: Handler timeout")
-
-type timeoutHandler struct {
-	handler Handler
-	timeout func() <-chan time.Time // returns channel producing a timeout
-	body    string
-}
-
-func (h *timeoutHandler) errorBody() string {
-	if h.body != "" {
-		return h.body
-	}
-	return "<html><head><title>Timeout</title></head><body><h1>Timeout</h1></body></html>"
-}
-
-func (h *timeoutHandler) ServeHTTP(w ResponseWriter, r *Request) {
-	done := make(chan bool, 1)
-	tw := &timeoutWriter{w: w}
-	go func() {
-		h.handler.ServeHTTP(tw, r)
-		done <- true
-	}()
-	select {
-	case <-done:
-		return
-	case <-h.timeout():
-		tw.mu.Lock()
-		defer tw.mu.Unlock()
-		if !tw.wroteHeader {
-			tw.w.WriteHeader(StatusServiceUnavailable)
-			tw.w.Write([]byte(h.errorBody()))
-		}
-		tw.timedOut = true
-	}
-}
-
-type timeoutWriter struct {
-	w ResponseWriter
-
-	mu          sync.Mutex
-	timedOut    bool
-	wroteHeader bool
-}
-
-func (tw *timeoutWriter) Header() Header {
-	return tw.w.Header()
-}
-
-func (tw *timeoutWriter) Write(p []byte) (int, error) {
-	tw.mu.Lock()
-	timedOut := tw.timedOut
-	tw.mu.Unlock()
-	if timedOut {
-		return 0, ErrHandlerTimeout
-	}
-	return tw.w.Write(p)
-}
-
-func (tw *timeoutWriter) WriteHeader(code int) {
-	tw.mu.Lock()
-	if tw.timedOut || tw.wroteHeader {
-		tw.mu.Unlock()
-		return
-	}
-	tw.wroteHeader = true
-	tw.mu.Unlock()
-	tw.w.WriteHeader(code)
-}
-
-// tcpKeepAliveListener sets TCP keep-alive timeouts on accepted
-// connections. It's used by ListenAndServe and ListenAndServeTLS so
-// dead TCP connections (e.g. closing laptop mid-download) eventually
-// go away.
-type tcpKeepAliveListener struct {
-	*net.TCPListener
-}
-
-func (ln tcpKeepAliveListener) Accept() (c net.Conn, err error) {
-	tc, err := ln.AcceptTCP()
-	if err != nil {
-		return
-	}
-	tc.SetKeepAlive(true)
-	tc.SetKeepAlivePeriod(3 * time.Minute)
-	return tc, nil
-}
-
-// globalOptionsHandler responds to "OPTIONS *" requests.
-type globalOptionsHandler struct{}
-
-func (globalOptionsHandler) ServeHTTP(w ResponseWriter, r *Request) {
-	w.Header().Set("Content-Length", "0")
-	if r.ContentLength != 0 {
-		// Read up to 4KB of OPTIONS body (as mentioned in the
-		// spec as being reserved for future use), but anything
-		// over that is considered a waste of server resources
-		// (or an attack) and we abort and close the connection,
-		// courtesy of MaxBytesReader's EOF behavior.
-		mb := MaxBytesReader(w, r.Body, 4<<10)
-		io.Copy(ioutil.Discard, mb)
-	}
-}
+)
 
 type eofReaderWithWriteTo struct{}
 
@@ -1991,28 +31,6 @@
 // Verify that an io.Copy from an eofReader won't require a buffer.
 var _ io.WriterTo = eofReader
 
-// initNPNRequest is an HTTP handler that initializes certain
-// uninitialized fields in its *Request. Such partially-initialized
-// Requests come from NPN protocol handlers.
-type initNPNRequest struct {
-	c *tls.Conn
-	h serverHandler
-}
-
-func (h initNPNRequest) ServeHTTP(rw ResponseWriter, req *Request) {
-	if req.TLS == nil {
-		req.TLS = &tls.ConnectionState{}
-		*req.TLS = h.c.ConnectionState()
-	}
-	if req.Body == nil {
-		req.Body = eofReader
-	}
-	if req.RemoteAddr == "" {
-		req.RemoteAddr = h.c.RemoteAddr().String()
-	}
-	h.h.ServeHTTP(rw, req)
-}
-
 // loggingConn is used for debugging.
 type loggingConn struct {
 	name string

